%% intorduction
<<echo=FALSE>>=
require(RGtk2)
@ 

%% Technical, but short beginning

As the name implies, the \pkg{RGtk2} package is an interface, or
binding, between \R\/ and \GTK, a mature, cross-platform GUI
toolkit. The letters \emph{GTK} stand for the \emph{GIMP ToolKit},
with the word \emph{GIMP} recording the origin of the library as part
of the GNU Image Manipulation Program. \GTK\/ provides the same
widgets on every platform, though it can be customized to emulate
platform-specific look and feel. The library is written in
\proglang{C}, which facilitates access from languages like
\proglang{R} that are also implemented in \proglang{C}. \GTK\/ is
licensed under the \textit{Lesser GNU Public License} (LGPL), while
\pkg{RGtk2} is under the \textit{GNU Public License} (GPL).
The package is available from the Comprehensive \proglang{R} Archive
Network (CRAN) at \url{http://CRAN.R-project.org/package=RGtk2}.

The name \pkg{RGtk2} also implies that there exists a package named
\pkg{RGtk}, which is indeed the case. The original \pkg{RGtk} is bound
to the previous generation of \GTK\/, version 1.2. \pkg{RGtk2} is
based on \pkg{GTK+ 2.0}, the current generation. This book covers
\pkg{RGtk2} specifically, although many of the fundamental features of
\pkg{RGtk2} are inherited from \pkg{RGtk}. 

\pkg{RGtk2} provides virtually all of the functionality in \GTK\/ to
the \R\/ programmer. In addition, \pkg{RGtk2} interfaces with several
other libraries in the \GTK\/ stack: Pango for font rendering; Cairo
for vector graphics; GdkPixbuf for image manipulation; GIO for
synchronous and asynchronous input/output for files and network
resources; ATK for accessible interfaces; and GDK, an abstraction over
the native windowing system, supporting either X11 or Windows. These
libraries are multi-platform and extensive and have been used for many
major projects, such as the Linux versions of Firefox and Open Office.

The API of each of these libraries is mapped to \R\/ in a way that is
consistent with \R\/ conventions and familiar to the \R\/
user. Much of the \pkg{RGtk2} API consists of autogenerated \R\/
functions that call into one of the underlying libraries. For
example, the \R\/ function \function{gtkContainerAdd} eventually calls
the C function \code{gtk\_container\_add}. The naming convention is
that the C name has its underscores removed and each following letter
capitalized (camelback style).

The full API for \GTK\/ is quite large, and complete documentation of
it is beyond our scope. However, the \GTK\/ documentation is
algorithmically converted into the \R\/ help format during the
generation of \pkg{RGtk2}. This conveniently allows the programmer to
refer to the appropriate documentation within an \R\/ session, without
having to consult a web page, such as
\url{https://developer-old.gnome.org/gtk2/stable/}, which lists the
\proglang{C} API of the stable version of \GTK.

In this chapter, we give an overview of how \pkg{RGtk2} maps the
\GTK\/ API, including its classes, constructors, methods, properties,
signals and enumerations, to an \R-level API that is relatively
familiar to, and convenient for, an \R\/ user. 
% A simple GUI will be
% gradually constructed to demonstrate the API.

%%% ------- OOP --------------

\section{Synopsis of the \pkg{RGtk2} API}

Constructing a GUI with \pkg{RGtk2} generally proceeds by constructing
a widget and then configuring it by calling methods and setting
properties. Handlers are connected to signals, and the widget is
combined with other widgets to form the GUI. For example:
<<gtk-overview-initial-example>>=
button <- gtkButton("Click Me")
button['image'] <- gtkImage(stock = "gtk-apply", 
                            size = "button")
gSignalConnect(button, "clicked", function(button) {
  message("Hello World!")
})
##
window <- gtkWindow(show = FALSE)
window$add(button)
window$showAll()
@ 
% 
Once one understands the syntax and themes of the above example, it is
only a matter of reading through the proceeding chapters and the
documentation to discover all of the widgets and their features. The
rest of this chapter will explain these basic components of the API.

\section{Objects and classes}

In any toolkit, all widget types have functionality in common. For
example, they are all drawn on the screen in a consistent style. They
can be hidden and shown again. To formalize this relationship and to
simplify implementation by sharing code between widgets, \GTK\/,
like many other toolkits, defines an inheritance hierarchy for its
widget types. In the parlance of object-oriented programming, each
type is represented by a \textit{class}.

For specifying the hierarchy, \GTK\/ relies on \pkg{GObject}, a
\proglang{C} library that implements a \iprogram{class structure}class-based, single-inheritance
object-oriented system. A \pkg{GObject} class encapsulates behaviors
that all instances of the class share. Every class has at most one
parent through which it inherits the behaviors of its ancestors. A
subclass can override some specific inherited behaviors. The interface
defined by a class consists of constructors, methods, properties,
and signals. 

The type system supports \iprogram{reflection}reflection, so we can, for example, obtain a
list of the ancestors for a given class:
<<gtk-intro-classes-ancestors>>=
gTypeGetAncestors("GtkWidget")
@ 
%
For those familiar with object-oriented programming in R, the returned
character vector could be interpreted as it were a class attribute on
an S3 object.

Single inheritance can be restrictive when a class performs multiple
roles in a program. To circumvent this, \GTK\/ adopts the popular
concept of the \iprogram{interface}\defn{interface}, which is essentially a contract
that specifies which methods, properties and signals a class must
implement. As with languages like Java and \proglang{C\#}, a class can
\textit{implement} multiple interfaces, and an interface can be
composed of other interfaces. An interface allows the programmer to
treat all instances of implementing classes in a similar way. However,
unlike class inheritance, the implementation of the methods,
properties and signals is not shared. For example, we list the
interfaces implemented by \class{GtkWidget}:
<<gtk-intro-class-interfaces>>=
gTypeGetInterfaces("GtkWidget")
@ 

We explain the constructors, methods, properties and signals of
classes and interfaces in the following sections and demonstrate them
in the construction of a simple ``Hello World'' GUI, shown in
Figure~\ref{fig:hello-world}. A more detailed and technical
explanation of \pkg{GObject} is available in
Chapter~\ref{chapter:extending-GTK}.

\begin{figure}[h!tbp]
  \begin{center}
    \includegraphics[width=2in]{hello-world.png}
    \caption{\label{fig:hello-world}``Hello World'' in GTK+. 
      A window containing a single button displaying a label with the text
      ``Hello World''.}
  \end{center}
\end{figure}

\section{Constructors}

The next few sections will contribute to a unifying example that
displays a button in a window. When clicked, the button will print a
message to the R console. The first step in our example is to create a
top-level window to contain our GUI.  Creating an instance of a GTK\/
widget requires calling a single \R\/ function, known as a
constructor. Following \R\/ conventions, the constructor for a class
has the same name as the class, except the first character is
lowercase. The following statement constructs an instance of the
\code{GtkWindow} class:
<<intro-constructor-gtkWindow>>=
window <- gtkWindow("toplevel", show = FALSE)
@
%
The first argument to the constructor for \code{GtkWindow} instructs
the window manager to treat the window as top-level.  The \code{show}
argument is the last argument for every widget constructor. It
indicates whether the widget should be made visible immediately after
construction.  The default value of \code{show} is \code{TRUE}. In
this case we want to defer showing the window until after we finish
constructing our simple GUI.

At the \GTK\/ level, a class usually has multiple constructors, each
implemented as a separate C function. In \pkg{RGtk2}, the names of
these functions all end with \code{New}. The ``meta'' constructor
\function{gtkWindow}, called above, automatically delegates to one of
the low-level constructors, based on the provided arguments.
We prefer these shorter, more flexible constructors, such as
\function{gtkWindow} or \function{gtkButton}, but note their
documentation is provided by the \R\/ package author and is in
addition to the formal API. These constructors can take many
arguments, and only some subsets of the arguments may be specified at
once. For example, this call
<<gtk-overview-construct-image, results=hide>>=
gtkImage(stock = "gtk-apply", size = "button")
@ 
% 
uses only two arguments, \argument{stock}{gtkImage} and
\argument{size}{gtkImage}, which always must be specified
together. The entire signature is more complex:
<<gtk-overview-construct-image-args, eval=FALSE>>=
args(gtkImage)
@ 
\begin{Soutput}
function (size, mask = NULL, pixmap = NULL, image = NULL, 
    filename, pixbuf = NULL, stock.id, icon.set, animation, 
    icon, show = TRUE)  
\end{Soutput}
A \GTK\/ object created by the \R\/ user has an \R-level object as its
proxy. Thus, \code{window} is a reference to a \class{GtkWindow}
instance. \iprogram{references}\iprogram{variable scope}A reference object will not be copied before
modification. This is different from the behavior of most \R\/
objects. For example, calling \function{abs} on a numeric vector does
not change the value assigned to the original symbol:
<<gtk-overview-objects-value>>=
a <- -1
abs(a)
a
@ 
% 
Setting the text label on our button, however, will change the
original value:
<<gtk-overview-objects-ref>>=
gtkButtonSetLabel(button, "New text")
gtkButtonGetLabel(button)
@ 
% 
If this widget were displayed on the screen, the label would also be
updated.

The class hierarchy of an object is represented by the
\code{class} attribute. One interprets the attribute according to S3
conventions, so that the class names are in order from most to least
derived:
<<intro-constructor-classes, eval=FALSE>>=
class(window)
@
\begin{Soutput}
[1] "GtkWindow"   "GtkBin"      "GtkContainer"     
[4] "GtkWidget"   "GtkObject"   "GInitiallyUnowned"
[7] "GObject"     "RGtkObject" 
\end{Soutput}
%
We find that the \class{GtkWindow} class inherits methods,
properties, and signals from the \class{GtkBin}, \class{GtkContainer},
\class{GtkWidget}, \class{GtkObject}, \class{GInitiallyUnowned}, and
\class{GObject} classes. Every type of \GTK\/ widget inherits from
the base \code{GtkWidget} class, which implements the general
characteristics shared by all widget classes, e.g., properties storing
the location and background color; methods for hiding, showing and
painting the widget. We can also query \code{window} for the
interfaces it implements:
<<intro-constructor-interfaces>>=
interface(window)
@ % In the next version of RGtk2, this will become just 'interface'

When the underlying \GTK\/ object is destroyed, i.e., deleted
from memory, the class of the proxy object is set to \class{<invalid>},
indicating that it can no longer be manipulated.

\section{Methods}

The next steps in our example are to create a ``Hello World'' button
and to place the button in the window that we have already
created. This depends on an understanding of how of one
programmatically manipulates widgets by invoking methods.  In
\pkg{RGtk2}, a method represents a type of message that is passed to a
widget. Methods are implemented as functions that take an instance of
their class as the first argument, and instruct the widget to perform
some behavior, according to any additional parameters.

Although class information is stored in the style of S3, \pkg{RGtk2}
introduces its own mechanism for method\iprogram{method dispatch}
dispatch.\footnote{\pkg{RGtk2} uses \R's standard dollar-sign
  notation (also used with reference classes) for class-based method
  dispatch.}  \iprogram{R's object oriented notation}The call \code{obj\$method(...)}  resolves to a function
call \code{f(obj,...)}. The function is found by looking for any
function that matches the pattern \emph{classNameMethodName}, the
concatenation of one of the names from \code{class(obj)} or
\code{interface(obj)} with the method name. The search begins with the
interfaces and proceeds through each character vector in order.

For instance, if \code{win} is a \function{gtkWindow} instance, then
to resolve the call \code{win\$add(widget)} \pkg{RGtk2} considers
\function{gtkBuildableAdd}, \function{atkImplementorIfaceAdd},
\function{gtkWindowAdd}, \function{gtkBinAdd} and finally finds
\function{gtkContainerAdd}, which is called as
\code{gtkContainerAdd(win, widget)}. The \method{\$}{GObject} method
for \pkg{RGtk2} objects does the work.

We take advantage of this convenience when we add the ``Hello World''
button to our window and set its size:
<<intro-methods-button>>=
button <- gtkButton("Hello World")
window$add(button)
window$setDefaultSize(200, 200)
@ 
%
The above code calls the \function{gtkContainerAdd} and
\function{gtkWindowSetDefaultSize} functions with less typing and less
demands on the memory of the user.

Understanding this mechanism allows us to add to the \pkg{RGtk2}
API. For instance, we can add to the button API with
<<gtkButtonAddApi>>=
gtkButtonSayHello <- function(obj, target) 
  obj$setLabel(paste("Hello", target))
button$sayHello("World")
button$getLabel()
@ 

%% common methods
Some common methods are inherited by all widgets, as they are defined
in the base \class{GtkWidget} class. These include: 
\method{show}{GtkWidget} to specify that the widget should be drawn;
\method{hide}{GtkWidget} to hide the widget until specified;
\method{destroy}{GtkWidget} to destroy a widget and clear up any
references to it; \method{getParent}{GtkWidget} to find the parent
container of the widget; \method{modifyBg}{GtkWidget} to modify the
background color of a widget; and \method{modifyFg}{GtkWidget} to
modify the foreground color.


\section{Properties}
\iprogram{properties}

%% --------- Properties ------------
The \GTK\/ API uses properties to store public object
state. Properties are similar to R attributes and even more so to S4
slots. They are inherited, typed, self-describing and
\iprogram{encapsulation}encapsulated, so that an object can intercept
access to the underlying data, if any (some properties may be fully
dynamic). A list of properties definitions belonging to the widget is
returned by its \method{getPropInfo}{GObject} method. Calling
\function{names} on the object returns the property
names. Auto-completion of property names is gained as a side effect.
For the button just defined, we can see the first eight properties
listed with:
<<showProperties>>=
head(names(button), n = 8)                 # or b$getPropInfo()
@ 

Some commonly used properties are: \code{parent}, to store the parent widget
(if any); \code{user-data}, which allows one to store arbitrary data
with the widget; and \code{sensitive}, to control whether a widget can
receive user events. 

There are a few different ways to access these properties. The methods
\method{get}{GObject} and \method{set}{GObject} get and set properties
of a widget, respectively. The set function treats the argument names
as the property names, and setting multiple properties at once is
supported. Here we add an icon to the top-left corner of our window
and set the title:
<<intro-props-get-set>>=
image <- gdkPixbuf(filename = imagefile("rgtk-logo.gif"))
window$set(icon = image[[1]], title = "Hello World 1.0")
@ 

Additionally, most user-accessible properties have specific \code{get} and
\code{set} methods defined for them. For example, to set the title of
the window, we could have used the \method{setTitle}{GtkWindow} method
and verified the change with \method{getTitle}{GtkWindow}.
<<>>=
window$setTitle("Hello World 1.0")
window$getTitle()
@ 

\paragraph{The \code{[} and \code{[\ASSIGN} methods}
\pkg{RGtk2} provides the convenient and familiar \code{[} and
\code{[\ASSIGN} methods to get and access an object's properties. In our example,
we might check the window to ensure that it is not yet visible with:
<<intro-props-visible>>=
window["visible"]
@
Finally, we can make our window visible by setting the ``visible'' property,
although calling \function{gtkWidgetShow} is more conventional:
<<intro-props-show>>=
window["visible"] <- TRUE 
window$show() # same effect
@ 

For ease of referencing the appropriate help pages, we tend to use the
full method name in the examples, although at times the move \R-like
vector notation will be used for commonly accessed properties.

%%% ------ Signals ----------

\section{Events and signals}

In \pkg{RGtk2}, a user action, such as a mouse click, key press or
drag and drop motion triggers the widget to emit a corresponding
signal.  A GUI can be made interactive by specifying a callback
function to be invoked upon the emission of a particular signal.

The signals provided by a class or interface are returned by the
function \function{gTypeGetSignals}. For example
<<>>=
names(gTypeGetSignals("GtkButton"))
@ 
shows the ``clicked'' signal in addition to others. Note that this
only lists the signals provided directly by the \class{GtkButton}. To
list all inherited signals, we need to loop over the hierarchy, but it
is not common to do this in practice, as the documentation includes
information on the signals.

The \function{gSignalConnect} function adds a callback to a widget's
signal. Its signature is
<<eval=FALSE>>=
args(gSignalConnect)
@
\begin{Soutput}
function (obj, signal, f, data = NULL, after = FALSE, 
          user.data.first = FALSE) 
\end{Soutput}
%
The basic usage is to call \function{gSignalConnect} to connect a
callback function \argument{f}{gSignalConnect} to the signal named
\argument{signal}{gSignalConnect} belonging to the object
\argument{obj}{gSignalConnect}. The function returns an identifier for
managing the connection. This is not usually necessary to store, but uses will be
discussed later.

We demonstrate \code{gSignalConnect} by adding a callback to our ``Hello World''
example, so that ``Hello World'' is printed to the console when the
button is clicked:
<<intro-signals-hello-world>>=
gSignalConnect(button, "clicked", 
               function(button) message("Hello world!"))
@ 
%

We now review the remaining arguments. The
\argument{data}{gSignalConnect} argument allows arbitrary data to be
passed to the callback.  The
\argument{user.data.first}{gSignalConnect} argument specifies if the
\argument{data}{gSignalConnect} argument should be the first argument
to the callback or (the default) the last.  The
\argument{after}{gSignalConnect} argument is a logical value
indicating if the callback should be called after the default handler
(see \command{?gSignalConnect}).

%% the callback
The signature for the callback varies for each signal. Unless
\code{user.data.first} is \code{TRUE}, the first argument is the
widget. Other arguments are possible depending on the signal type. For
window events, the second argument is a \class{GdkEvent} type, which
can carry with it extra information about the event that occurred. The
\GTK\/ API lists the signature of each signal.

It is important to note that the widget, and possibly other arguments,
are references, so their manipulation has side effects outside of the
callback. This is obviously a critical feature, but it is one that
may be surprising to the \R\/ user.

<<results=hide>>=
window <- gtkWindow(); window['title'] <- "test signals"
x <- 1; 
button <- gtkButton("click me"); window$add(button)
gSignalConnect(button, signal = "clicked", 
               f = function(button) {
                 button$setData("x", 2)
                 x <- 2
                 return(TRUE)
               })
@ 
Then after clicking, we would have
<<echo=FALSE>>=
button$setData("x", 2)                        # fix non-interactivity
@ 

<<>>=
cat(x, button$getData("x"), "\n") # 1 and 2
@ 

Callbacks for signals emitted by window manager events are expected to
return a logical value. Failure to do so can cause errors to be
raised. A return value of \code{TRUE} indicates that no further
callbacks should be called, whereas \code{FALSE} indicates that the
next callback should be called. In other words, the return value
indicates whether the handler has consumed the event. In the following
example, only the first two callbacks are executed when the user
clicks the button:
<<>>=
button <- gtkButton("click")
window <- gtkWindow()
window$add(button)
gSignalConnect(button, "button-press-event", 
               function(button, event, data) {
                 message("hi"); return(FALSE)
               })
gSignalConnect(button, "button-press-event", 
               function(button, event, data) {
                 message("and"); return(TRUE)
               })
gSignalConnect(button, "button-press-event", 
               function(button, event, data) {
                 message("bye"); return(TRUE)
               })
@ 

%% multiple callbacks; remove; block
Multiple callbacks can be assigned to each signal. They will be
processed in the order they were bound to the signal.  The
\function{gSignalConnect} function returns an ID that can be used to
disconnect a handler, if desired, using
\function{gSignalHandlerDisconnect}. To temporarily block a handler,
call \function{gSignalHandlerBlock} and then
\function{gSignalHandlerUnblock} to unblock. The man page for
\function{gSignalConnect} gives the details.

%%% ------ constants --------

\section{Enumerated types and flags}
\iprogram{enumerations}

At the beginning of our example, we constructed the window thusly: 
<<intro-enum-window, eval=FALSE>>=
window <- gtkWindow("toplevel", show = FALSE)
@
%
The first parameter indicates the window type. The set of possible
window types is specified by what in C is known as an
\iprogram{enumeration}\defn{enumeration}. A value from an enumeration can be thought of as a
length one factor in \R. The possible values defined by the
enumeration are analogous to the factor levels.  Since enumerations
are foreign to R, \pkg{RGtk2} accepts string
representations of enumeration values, like \code{"toplevel"}. 

For every \GTK\/ enumeration, \pkg{RGtk2} provides an R
vector that maps the nicknames to the underlying numeric values.  In
the above case, the vector is named \gtkenum{GtkWindowType}.
<<intro-enum-GtkWindowType>>=
GtkWindowType
@ 
%
The names of the vector indicate the allowed nickname for each value
of the enumeration. It is rarely necessary to explicitly use the
enumeration vectors; specifying the nickname will work in most cases,
including all method invocations, and is preferable as it is easier
for human readers to comprehend.

Flags are an extension of enumerations, where the value of each member
is a unique power of two, so that the values can be combined
unambiguously. An example of a flag enumeration is
\class{GtkWidgetFlags}.
<<intro-enum-GtkWidgetFlags>>=
GtkWidgetFlags
@ 
%
\class{GtkWidgetFlags} represents the possible flags that can be set
on a widget. We can retrieve the flags currently set on our window:



<<intro-enum-gtkWidgetFlags, results=hide>>=
window$flags()
@ % output will be much prettier with next version of RGtk2
\begin{Soutput}
GtkWidgetFlags: toplevel, realized, mapped, visible, 
         sensitive, parent-sensitive, double-buffered
\end{Soutput}
%
Flag values can be combined using 
%% JV: \function{\\|}, 
\verb+|+
the bitwise
\textit{OR}. The \function{\&} function, the bitwise \textit{AND},
allows one to check whether a value belongs to a combination. For
example, we could check whether our window is top-level:
<<intro-enum-toplevel>>=
(window$flags() & GtkWidgetFlags["toplevel"]) > 0
@ 

%% --------- Event Loop

\section{The event loop}
\iprogram{event loop}

\pkg{RGtk2} integrates the \GTK\/ and \R\/ event loops by treating the
\R\/ loop as the master and iterating the \GTK\/ event loop whenever R
is idle.  During a long calculation, the GUI can seem unresponsive. To
avoid this, the following construct should be inserted into the long
running algorithm in order to ensure that \GTK\/ events are
periodically processed:
<<>>=
while(gtkEventsPending()) 
  gtkMainIteration()
@ 
This is often useful, for example, to update a progress bar.

If one runs an \pkg{RGtk2} script non-interactively, such as by
assigning an icon to launch a GUI under Windows, R will exit after
the script is finished and the GUI will disappear just after it
appears. To work around this, call the function \function{gtkMain} to
run the main loop until the function \function{gtkMainQuit} is
called. Since there is no interactive session, \function{gtkMainQuit}
should be called through some event handler.

%% FIXME: here or in the appendix?
\section{Importing a GUI from Glade}
\label{sec:gtk-glade}

\SweaveInput{Glade}

%% MOVEME: seems like integration between gWidgets and native toolkits
%% belongs in the gWidgets chapters. Otherwise, each toolkit chapter
%% needs to say the same thing. Better to have it in one place.

% \section{RGtk2 and gWidgetsRGtk2}
% \label{sec:RGtk2:gWidgetsRGtk2}


% The widgets described above, are also available through
% \pkg{gWidgetsRGtk2}. The two packages can be used together, for the
% most part. The \code{add} method of \pkg{gWidgetsRGtk2} can be used to
% add an \pkg{RGtk2} widget to a \code{gWidgetsRGtk2}
% container. Whereas, the \code{getToolkitWidget} method will (usually)
% return the \pkg{RGtk2} component to use within \pkg{RGtk2}.

%% Views example in next chapter?
