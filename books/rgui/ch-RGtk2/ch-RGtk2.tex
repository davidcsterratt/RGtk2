
% XXX- discuss GtkBin; which widgets have a window, which do not --image and label do not, and we might want them too,
%   modify_bg() only affects widgets that have an associated gtk.gdk.Window.
% > Widgets that do not have an associated window include .... gtk.Arrow,
% > gtk.Bin, gtk.Box, gtk.Button, gtk.CheckButton, gtk.Fixed , gtk.Image ,
% > gtk.Label , gtk.MenuItem , gtk.Notebook , gtk.Paned , gtk.RadioButton ,
% > gtk.Range , gtk.ScrolledWindow , gtk.Separator , gtk.Table , gtk.Toolbar ,
% > gtk.AspectFrame , gtk.Frame , gtk.VBox , gtk.HBox , gtk.VSeparator ,
% > gtk.HSeparator . These widgets can be added to a gtk.EventBox to overcome
% > this limitation.




%% RGtk2 chapter
\chapter{RGtk2: Overview}
%%\section{Introduction}
\label{sec:RGtk2-Introduction}
%% intorduction

%% Technical, but short beginning

As the name implies, the \pkg{RGtk2} package is an interface, or
binding, between \R\/ and \GTK, a mature, cross-platform GUI
toolkit. The letters \emph{GTK} stand for the \emph{GIMP ToolKit},
with the word \emph{GIMP} recording the origin of the library as part
of the GNU Image Manipulation Program. \GTK\/ provides the same
widgets on every platform, though it can be customized to emulate
platform-specific look and feel. The library is written in
\proglang{C}, which facilitates access from languages like
\proglang{R} that are also implemented in \proglang{C}. \GTK\/ is
licensed under the \textit{Lesser GNU Public License} (LGPL), while
\pkg{RGtk2} is under the \textit{GNU Public License} (GPL).
The package is available from the Comprehensive \proglang{R} Archive
Network (CRAN) at \url{http://CRAN.R-project.org/package=RGtk2}.

The name \pkg{RGtk2} also implies that there exists a package named
\pkg{RGtk}, which is indeed the case. The original \pkg{RGtk} is bound
to the previous generation of \GTK\/, version 1.2. \pkg{RGtk2} is
based on \pkg{GTK+ 2.0}, the current generation. This book covers
\pkg{RGtk2} specifically, although many of the fundamental features of
\pkg{RGtk2} are inherited from \pkg{RGtk}. 

\pkg{RGtk2} provides virtually all of the functionality in \GTK\/ to
the \R\/ programmer. In addition, \pkg{RGtk2} interfaces with several
other libraries in the \GTK\/ stack: Pango for font rendering; Cairo
for vector graphics; GdkPixbuf for image manipulation; GIO for
synchronous and asynchronous input/output for files and network
resources; ATK for accessible interfaces; and GDK, an abstraction over
the native windowing system, supporting either X11 or Windows. These
libraries are multi-platform and extensive and have been used for many
major projects, such as the Linux versions of Firefox and Open Office.

The API of each of these libraries is mapped to \R\/ in a way that is
consistent with \R\/ conventions and familiar to the \R\/
user. Much of the \pkg{RGtk2} API consists of autogenerated \R\/
functions that call into one of the underlying libraries. For
example, the \R\/ function \function{gtkContainerAdd} eventually calls
the C function \code{gtk\_container\_add}. The naming convention is
that the C name has its underscores removed and each following letter
capitalized (camelback style).

The full API for \GTK\/ is quite large, and complete documentation of
it is beyond our scope. However, the \GTK\/ documentation is
algorithmically converted into the \R\/ help format during the
generation of \pkg{RGtk2}. This conveniently allows the programmer to
refer to the appropriate documentation within an \R\/ session, without
having to consult a web page, such as
\url{https://developer-old.gnome.org/gtk2/stable/}, which lists the
\proglang{C} API of the stable version of \GTK.

In this chapter, we give an overview of how \pkg{RGtk2} maps the
\GTK\/ API, including its classes, constructors, methods, properties,
signals and enumerations, to an \R-level API that is relatively
familiar to, and convenient for, an \R\/ user. 
% A simple GUI will be
% gradually constructed to demonstrate the API.

%%% ------- OOP --------------

\section{Synopsis of the \pkg{RGtk2} API}

Constructing a GUI with \pkg{RGtk2} generally proceeds by constructing
a widget and then configuring it by calling methods and setting
properties. Handlers are connected to signals, and the widget is
combined with other widgets to form the GUI. For example:
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton("Click Me")
 button['image'] <- gtkImage(stock = "gtk-apply", 
                             size = "button")
 gSignalConnect(button, "clicked", function(button) {
   message("Hello World!")
 })
 ##
 window <- gtkWindow(show = FALSE)
 window$add(button)
 window$showAll()
\end{Sinput}
\end{Schunk}
% 
Once one understands the syntax and themes of the above example, it is
only a matter of reading through the proceeding chapters and the
documentation to discover all of the widgets and their features. The
rest of this chapter will explain these basic components of the API.

\section{Objects and classes}

In any toolkit, all widget types have functionality in common. For
example, they are all drawn on the screen in a consistent style. They
can be hidden and shown again. To formalize this relationship and to
simplify implementation by sharing code between widgets, \GTK\/,
like many other toolkits, defines an inheritance hierarchy for its
widget types. In the parlance of object-oriented programming, each
type is represented by a \textit{class}.

For specifying the hierarchy, \GTK\/ relies on \pkg{GObject}, a
\proglang{C} library that implements a \iprogram{class structure}class-based, single-inheritance
object-oriented system. A \pkg{GObject} class encapsulates behaviors
that all instances of the class share. Every class has at most one
parent through which it inherits the behaviors of its ancestors. A
subclass can override some specific inherited behaviors. The interface
defined by a class consists of constructors, methods, properties,
and signals. 

The type system supports \iprogram{reflection}reflection, so we can, for example, obtain a
list of the ancestors for a given class:
\begin{Schunk}
\begin{Sinput}
 gTypeGetAncestors("GtkWidget")
\end{Sinput}
\begin{Soutput}
[1] "GtkWidget"         "GtkObject"        
[3] "GInitiallyUnowned" "GObject"          
\end{Soutput}
\end{Schunk}
%
For those familiar with object-oriented programming in R, the returned
character vector could be interpreted as it were a class attribute on
an S3 object.

Single inheritance can be restrictive when a class performs multiple
roles in a program. To circumvent this, \GTK\/ adopts the popular
concept of the \iprogram{interface}\defn{interface}, which is essentially a contract
that specifies which methods, properties and signals a class must
implement. As with languages like Java and \proglang{C\#}, a class can
\textit{implement} multiple interfaces, and an interface can be
composed of other interfaces. An interface allows the programmer to
treat all instances of implementing classes in a similar way. However,
unlike class inheritance, the implementation of the methods,
properties and signals is not shared. For example, we list the
interfaces implemented by \class{GtkWidget}:
\begin{Schunk}
\begin{Sinput}
 gTypeGetInterfaces("GtkWidget")
\end{Sinput}
\begin{Soutput}
[1] "AtkImplementorIface" "GtkBuildable"       
\end{Soutput}
\end{Schunk}

We explain the constructors, methods, properties and signals of
classes and interfaces in the following sections and demonstrate them
in the construction of a simple ``Hello World'' GUI, shown in
Figure~\ref{fig:hello-world}. A more detailed and technical
explanation of \pkg{GObject} is available in
Chapter~\ref{chapter:extending-GTK}.

\begin{figure}[h!tbp]
  \begin{center}
    \includegraphics[width=2in]{hello-world.png}
    \caption{\label{fig:hello-world}``Hello World'' in GTK+. 
      A window containing a single button displaying a label with the text
      ``Hello World''.}
  \end{center}
\end{figure}

\section{Constructors}

The next few sections will contribute to a unifying example that
displays a button in a window. When clicked, the button will print a
message to the R console. The first step in our example is to create a
top-level window to contain our GUI.  Creating an instance of a GTK\/
widget requires calling a single \R\/ function, known as a
constructor. Following \R\/ conventions, the constructor for a class
has the same name as the class, except the first character is
lowercase. The following statement constructs an instance of the
\code{GtkWindow} class:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow("toplevel", show = FALSE)
\end{Sinput}
\end{Schunk}
%
The first argument to the constructor for \code{GtkWindow} instructs
the window manager to treat the window as top-level.  The \code{show}
argument is the last argument for every widget constructor. It
indicates whether the widget should be made visible immediately after
construction.  The default value of \code{show} is \code{TRUE}. In
this case we want to defer showing the window until after we finish
constructing our simple GUI.

At the \GTK\/ level, a class usually has multiple constructors, each
implemented as a separate C function. In \pkg{RGtk2}, the names of
these functions all end with \code{New}. The ``meta'' constructor
\function{gtkWindow}, called above, automatically delegates to one of
the low-level constructors, based on the provided arguments.
We prefer these shorter, more flexible constructors, such as
\function{gtkWindow} or \function{gtkButton}, but note their
documentation is provided by the \R\/ package author and is in
addition to the formal API. These constructors can take many
arguments, and only some subsets of the arguments may be specified at
once. For example, this call
\begin{Schunk}
\begin{Sinput}
 gtkImage(stock = "gtk-apply", size = "button")
\end{Sinput}
\end{Schunk}
% 
uses only two arguments, \argument{stock}{gtkImage} and
\argument{size}{gtkImage}, which always must be specified
together. The entire signature is more complex:
\begin{Schunk}
\begin{Sinput}
 args(gtkImage)
\end{Sinput}
\end{Schunk}
\begin{Soutput}
function (size, mask = NULL, pixmap = NULL, image = NULL, 
    filename, pixbuf = NULL, stock.id, icon.set, animation, 
    icon, show = TRUE)  
\end{Soutput}
A \GTK\/ object created by the \R\/ user has an \R-level object as its
proxy. Thus, \code{window} is a reference to a \class{GtkWindow}
instance. \iprogram{references}\iprogram{variable scope}A reference object will not be copied before
modification. This is different from the behavior of most \R\/
objects. For example, calling \function{abs} on a numeric vector does
not change the value assigned to the original symbol:
\begin{Schunk}
\begin{Sinput}
 a <- -1
 abs(a)
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\begin{Sinput}
 a
\end{Sinput}
\begin{Soutput}
[1] -1
\end{Soutput}
\end{Schunk}
% 
Setting the text label on our button, however, will change the
original value:
\begin{Schunk}
\begin{Sinput}
 gtkButtonSetLabel(button, "New text")
 gtkButtonGetLabel(button)
\end{Sinput}
\begin{Soutput}
[1] "New text"
\end{Soutput}
\end{Schunk}
% 
If this widget were displayed on the screen, the label would also be
updated.

The class hierarchy of an object is represented by the
\code{class} attribute. One interprets the attribute according to S3
conventions, so that the class names are in order from most to least
derived:
\begin{Schunk}
\begin{Sinput}
 class(window)
\end{Sinput}
\end{Schunk}
\begin{Soutput}
[1] "GtkWindow"   "GtkBin"      "GtkContainer"     
[4] "GtkWidget"   "GtkObject"   "GInitiallyUnowned"
[7] "GObject"     "RGtkObject" 
\end{Soutput}
%
We find that the \class{GtkWindow} class inherits methods,
properties, and signals from the \class{GtkBin}, \class{GtkContainer},
\class{GtkWidget}, \class{GtkObject}, \class{GInitiallyUnowned}, and
\class{GObject} classes. Every type of \GTK\/ widget inherits from
the base \code{GtkWidget} class, which implements the general
characteristics shared by all widget classes, e.g., properties storing
the location and background color; methods for hiding, showing and
painting the widget. We can also query \code{window} for the
interfaces it implements:
\begin{Schunk}
\begin{Sinput}
 interface(window)
\end{Sinput}
\begin{Soutput}
[1] "AtkImplementorIface" "GtkBuildable"       
\end{Soutput}
\end{Schunk}

When the underlying \GTK\/ object is destroyed, i.e., deleted
from memory, the class of the proxy object is set to \class{<invalid>},
indicating that it can no longer be manipulated.

\section{Methods}

The next steps in our example are to create a ``Hello World'' button
and to place the button in the window that we have already
created. This depends on an understanding of how of one
programmatically manipulates widgets by invoking methods.  In
\pkg{RGtk2}, a method represents a type of message that is passed to a
widget. Methods are implemented as functions that take an instance of
their class as the first argument, and instruct the widget to perform
some behavior, according to any additional parameters.

Although class information is stored in the style of S3, \pkg{RGtk2}
introduces its own mechanism for method\iprogram{method dispatch}
dispatch.\footnote{\pkg{RGtk2} uses \R's standard dollar-sign
  notation (also used with reference classes) for class-based method
  dispatch.}  \iprogram{R's object oriented notation}The call \code{obj\$method(...)}  resolves to a function
call \code{f(obj,...)}. The function is found by looking for any
function that matches the pattern \emph{classNameMethodName}, the
concatenation of one of the names from \code{class(obj)} or
\code{interface(obj)} with the method name. The search begins with the
interfaces and proceeds through each character vector in order.

For instance, if \code{win} is a \function{gtkWindow} instance, then
to resolve the call \code{win\$add(widget)} \pkg{RGtk2} considers
\function{gtkBuildableAdd}, \function{atkImplementorIfaceAdd},
\function{gtkWindowAdd}, \function{gtkBinAdd} and finally finds
\function{gtkContainerAdd}, which is called as
\code{gtkContainerAdd(win, widget)}. The \method{\$}{GObject} method
for \pkg{RGtk2} objects does the work.

We take advantage of this convenience when we add the ``Hello World''
button to our window and set its size:
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton("Hello World")
 window$add(button)
 window$setDefaultSize(200, 200)
\end{Sinput}
\end{Schunk}
%
The above code calls the \function{gtkContainerAdd} and
\function{gtkWindowSetDefaultSize} functions with less typing and less
demands on the memory of the user.

Understanding this mechanism allows us to add to the \pkg{RGtk2}
API. For instance, we can add to the button API with
\begin{Schunk}
\begin{Sinput}
 gtkButtonSayHello <- function(obj, target) 
   obj$setLabel(paste("Hello", target))
 button$sayHello("World")
 button$getLabel()
\end{Sinput}
\begin{Soutput}
[1] "Hello World"
\end{Soutput}
\end{Schunk}

%% common methods
Some common methods are inherited by all widgets, as they are defined
in the base \class{GtkWidget} class. These include: 
\method{show}{GtkWidget} to specify that the widget should be drawn;
\method{hide}{GtkWidget} to hide the widget until specified;
\method{destroy}{GtkWidget} to destroy a widget and clear up any
references to it; \method{getParent}{GtkWidget} to find the parent
container of the widget; \method{modifyBg}{GtkWidget} to modify the
background color of a widget; and \method{modifyFg}{GtkWidget} to
modify the foreground color.


\section{Properties}
\iprogram{properties}

%% --------- Properties ------------
The \GTK\/ API uses properties to store public object
state. Properties are similar to R attributes and even more so to S4
slots. They are inherited, typed, self-describing and
\iprogram{encapsulation}encapsulated, so that an object can intercept
access to the underlying data, if any (some properties may be fully
dynamic). A list of properties definitions belonging to the widget is
returned by its \method{getPropInfo}{GObject} method. Calling
\function{names} on the object returns the property
names. Auto-completion of property names is gained as a side effect.
For the button just defined, we can see the first eight properties
listed with:
\begin{Schunk}
\begin{Sinput}
 head(names(button), n = 8)                 # or b$getPropInfo()
\end{Sinput}
\begin{Soutput}
[1] "related-action"        "use-action-appearance"
[3] "user-data"             "name"                 
[5] "parent"                "width-request"        
[7] "height-request"        "visible"              
\end{Soutput}
\end{Schunk}

Some commonly used properties are: \code{parent}, to store the parent widget
(if any); \code{user-data}, which allows one to store arbitrary data
with the widget; and \code{sensitive}, to control whether a widget can
receive user events. 

There are a few different ways to access these properties. The methods
\method{get}{GObject} and \method{set}{GObject} get and set properties
of a widget, respectively. The set function treats the argument names
as the property names, and setting multiple properties at once is
supported. Here we add an icon to the top-left corner of our window
and set the title:
\begin{Schunk}
\begin{Sinput}
 image <- gdkPixbuf(filename = imagefile("rgtk-logo.gif"))
 window$set(icon = image[[1]], title = "Hello World 1.0")
\end{Sinput}
\end{Schunk}

Additionally, most user-accessible properties have specific \code{get} and
\code{set} methods defined for them. For example, to set the title of
the window, we could have used the \method{setTitle}{GtkWindow} method
and verified the change with \method{getTitle}{GtkWindow}.
\begin{Schunk}
\begin{Sinput}
 window$setTitle("Hello World 1.0")
 window$getTitle()
\end{Sinput}
\begin{Soutput}
[1] "Hello World 1.0"
\end{Soutput}
\end{Schunk}

\paragraph{The \code{[} and \code{[\ASSIGN} methods}
\pkg{RGtk2} provides the convenient and familiar \code{[} and
\code{[\ASSIGN} methods to get and access an object's properties. In our example,
we might check the window to ensure that it is not yet visible with:
\begin{Schunk}
\begin{Sinput}
 window["visible"]
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\end{Schunk}
Finally, we can make our window visible by setting the ``visible'' property,
although calling \function{gtkWidgetShow} is more conventional:
\begin{Schunk}
\begin{Sinput}
 window["visible"] <- TRUE 
 window$show() # same effect
\end{Sinput}
\end{Schunk}

For ease of referencing the appropriate help pages, we tend to use the
full method name in the examples, although at times the move \R-like
vector notation will be used for commonly accessed properties.

%%% ------ Signals ----------

\section{Events and signals}

In \pkg{RGtk2}, a user action, such as a mouse click, key press or
drag and drop motion triggers the widget to emit a corresponding
signal.  A GUI can be made interactive by specifying a callback
function to be invoked upon the emission of a particular signal.

The signals provided by a class or interface are returned by the
function \function{gTypeGetSignals}. For example
\begin{Schunk}
\begin{Sinput}
 names(gTypeGetSignals("GtkButton"))
\end{Sinput}
\begin{Soutput}
[1] "pressed"  "released" "clicked"  "enter"    "leave"   
[6] "activate"
\end{Soutput}
\end{Schunk}
shows the ``clicked'' signal in addition to others. Note that this
only lists the signals provided directly by the \class{GtkButton}. To
list all inherited signals, we need to loop over the hierarchy, but it
is not common to do this in practice, as the documentation includes
information on the signals.

The \function{gSignalConnect} function adds a callback to a widget's
signal. Its signature is
\begin{Schunk}
\begin{Sinput}
 args(gSignalConnect)
\end{Sinput}
\end{Schunk}
\begin{Soutput}
function (obj, signal, f, data = NULL, after = FALSE, 
          user.data.first = FALSE) 
\end{Soutput}
%
The basic usage is to call \function{gSignalConnect} to connect a
callback function \argument{f}{gSignalConnect} to the signal named
\argument{signal}{gSignalConnect} belonging to the object
\argument{obj}{gSignalConnect}. The function returns an identifier for
managing the connection. This is not usually necessary to store, but uses will be
discussed later.

We demonstrate \code{gSignalConnect} by adding a callback to our ``Hello World''
example, so that ``Hello World'' is printed to the console when the
button is clicked:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(button, "clicked", 
                function(button) message("Hello world!"))
\end{Sinput}
\end{Schunk}
%

We now review the remaining arguments. The
\argument{data}{gSignalConnect} argument allows arbitrary data to be
passed to the callback.  The
\argument{user.data.first}{gSignalConnect} argument specifies if the
\argument{data}{gSignalConnect} argument should be the first argument
to the callback or (the default) the last.  The
\argument{after}{gSignalConnect} argument is a logical value
indicating if the callback should be called after the default handler
(see \command{?gSignalConnect}).

%% the callback
The signature for the callback varies for each signal. Unless
\code{user.data.first} is \code{TRUE}, the first argument is the
widget. Other arguments are possible depending on the signal type. For
window events, the second argument is a \class{GdkEvent} type, which
can carry with it extra information about the event that occurred. The
\GTK\/ API lists the signature of each signal.

It is important to note that the widget, and possibly other arguments,
are references, so their manipulation has side effects outside of the
callback. This is obviously a critical feature, but it is one that
may be surprising to the \R\/ user.

\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window['title'] <- "test signals"
 x <- 1; 
 button <- gtkButton("click me"); window$add(button)
 gSignalConnect(button, signal = "clicked", 
                f = function(button) {
                  button$setData("x", 2)
                  x <- 2
                  return(TRUE)
                })
\end{Sinput}
\end{Schunk}
Then after clicking, we would have

\begin{Schunk}
\begin{Sinput}
 cat(x, button$getData("x"), "\n") # 1 and 2
\end{Sinput}
\begin{Soutput}
1 2 
\end{Soutput}
\end{Schunk}

Callbacks for signals emitted by window manager events are expected to
return a logical value. Failure to do so can cause errors to be
raised. A return value of \code{TRUE} indicates that no further
callbacks should be called, whereas \code{FALSE} indicates that the
next callback should be called. In other words, the return value
indicates whether the handler has consumed the event. In the following
example, only the first two callbacks are executed when the user
clicks the button:
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton("click")
 window <- gtkWindow()
 window$add(button)
 gSignalConnect(button, "button-press-event", 
                function(button, event, data) {
                  message("hi"); return(FALSE)
                })
 gSignalConnect(button, "button-press-event", 
                function(button, event, data) {
                  message("and"); return(TRUE)
                })
 gSignalConnect(button, "button-press-event", 
                function(button, event, data) {
                  message("bye"); return(TRUE)
                })
\end{Sinput}
\end{Schunk}

%% multiple callbacks; remove; block
Multiple callbacks can be assigned to each signal. They will be
processed in the order they were bound to the signal.  The
\function{gSignalConnect} function returns an ID that can be used to
disconnect a handler, if desired, using
\function{gSignalHandlerDisconnect}. To temporarily block a handler,
call \function{gSignalHandlerBlock} and then
\function{gSignalHandlerUnblock} to unblock. The man page for
\function{gSignalConnect} gives the details.

%%% ------ constants --------

\section{Enumerated types and flags}
\iprogram{enumerations}

At the beginning of our example, we constructed the window thusly: 
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow("toplevel", show = FALSE)
\end{Sinput}
\end{Schunk}
%
The first parameter indicates the window type. The set of possible
window types is specified by what in C is known as an
\iprogram{enumeration}\defn{enumeration}. A value from an enumeration can be thought of as a
length one factor in \R. The possible values defined by the
enumeration are analogous to the factor levels.  Since enumerations
are foreign to R, \pkg{RGtk2} accepts string
representations of enumeration values, like \code{"toplevel"}. 

For every \GTK\/ enumeration, \pkg{RGtk2} provides an R
vector that maps the nicknames to the underlying numeric values.  In
the above case, the vector is named \gtkenum{GtkWindowType}.
\begin{Schunk}
\begin{Sinput}
 GtkWindowType
\end{Sinput}
\begin{Soutput}
An enumeration with values:
toplevel    popup 
       0        1 
\end{Soutput}
\end{Schunk}
%
The names of the vector indicate the allowed nickname for each value
of the enumeration. It is rarely necessary to explicitly use the
enumeration vectors; specifying the nickname will work in most cases,
including all method invocations, and is preferable as it is easier
for human readers to comprehend.

Flags are an extension of enumerations, where the value of each member
is a unique power of two, so that the values can be combined
unambiguously. An example of a flag enumeration is
\class{GtkWidgetFlags}.
\begin{Schunk}
\begin{Sinput}
 GtkWidgetFlags
\end{Sinput}
\begin{Soutput}
A flag enumeration with values:
        toplevel        no-window         realized 
              16               32               64 
          mapped          visible        sensitive 
             128              256              512 
parent-sensitive        can-focus        has-focus 
            1024             2048             4096 
     can-default      has-default         has-grab 
            8192            16384            32768 
        rc-style  composite-child      no-reparent 
           16384           131072           262144 
   app-paintable receives-default  double-buffered 
          524288          1048576          2097152 
     no-show-all 
         4194304 
\end{Soutput}
\end{Schunk}
%
\class{GtkWidgetFlags} represents the possible flags that can be set
on a widget. We can retrieve the flags currently set on our window:



\begin{Schunk}
\begin{Sinput}
 window$flags()
\end{Sinput}
\end{Schunk}
\begin{Soutput}
GtkWidgetFlags: toplevel, realized, mapped, visible, 
         sensitive, parent-sensitive, double-buffered
\end{Soutput}
%
Flag values can be combined using 
%% JV: \function{\\|}, 
\verb+|+
the bitwise
\textit{OR}. The \function{\&} function, the bitwise \textit{AND},
allows one to check whether a value belongs to a combination. For
example, we could check whether our window is top-level:
\begin{Schunk}
\begin{Sinput}
 (window$flags() & GtkWidgetFlags["toplevel"]) > 0
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

%% --------- Event Loop

\section{The event loop}
\iprogram{event loop}

\pkg{RGtk2} integrates the \GTK\/ and \R\/ event loops by treating the
\R\/ loop as the master and iterating the \GTK\/ event loop whenever R
is idle.  During a long calculation, the GUI can seem unresponsive. To
avoid this, the following construct should be inserted into the long
running algorithm in order to ensure that \GTK\/ events are
periodically processed:
\begin{Schunk}
\begin{Sinput}
 while(gtkEventsPending()) 
   gtkMainIteration()
\end{Sinput}
\end{Schunk}
This is often useful, for example, to update a progress bar.

If one runs an \pkg{RGtk2} script non-interactively, such as by
assigning an icon to launch a GUI under Windows, R will exit after
the script is finished and the GUI will disappear just after it
appears. To work around this, call the function \function{gtkMain} to
run the main loop until the function \function{gtkMainQuit} is
called. Since there is no interactive session, \function{gtkMainQuit}
should be called through some event handler.

%% FIXME: here or in the appendix?
\section{Importing a GUI from Glade}
\label{sec:gtk-glade}

%% Using Glade

This book focuses almost entirely on the direct programmatic
construction of GUIs. Some developers prefer visually constructing a
GUI by pointing, clicking and dragging in another GUI, which one might
call a GUI builder, a type of RAD (Rapid Application Development)
tool. \pkg{Glade} is the primary GUI builder for \GTK\/ and
exports an interface as XML that is loadable by \class{GtkBuilder}. It
is freely available for all major platforms from
\url{http://glade.gnome.org/}. Documentation is also at that
location. 

We will assume that the reader has saved an interface as a
\class{GtkBuilder} XML file named \code{buildable.xml} and is ready to
load it with \pkg{RGtk2}:
\begin{Schunk}
\begin{Sinput}
 builder <- gtkBuilder()
 builder$addFromFile("buildable.xml")
\end{Sinput}
\begin{Soutput}
$retval
[1] 1

$error
NULL
\end{Soutput}
\end{Schunk}

The \method{getObject}{GtkBuilder} extracts a widget by its ID, which
is specified by the user through \pkg{Glade}. It normally
suffices to load the top-level widget, named \code{dialog1} in this
example, and show it:
\begin{Schunk}
\begin{Sinput}
 dialog1 <- builder$getObject("dialog1")
 dialog1$showAll()
\end{Sinput}
\end{Schunk}

In order to add behaviors to the GUI, we need to register R functions
as signal handlers. In \pkg{Glade}, the user should specify the
name of an R function as a handler for some signal. \pkg{RGtk2}
extends \class{GtkBuilder} to look up the functions and connect them
to the appropriate signals. Let us assume that the user has named the
\function{ok\_button\_clicked} function as the handler for the
\signal{clicked} signal on a \class{GtkButton}. The
\method{connectSignals}{GtkBuilder} method will establish that
connection and any others in the interface:
\begin{Schunk}
\begin{Sinput}
 ok_button_clicked <- function(button, userData) {
   message("hello world")
 }
 builder$connectSignals()
\end{Sinput}
\end{Schunk}
% 
The GUI should now be ready for use.

%% MOVEME: seems like integration between gWidgets and native toolkits
%% belongs in the gWidgets chapters. Otherwise, each toolkit chapter
%% needs to say the same thing. Better to have it in one place.

% \section{RGtk2 and gWidgetsRGtk2}
% \label{sec:RGtk2:gWidgetsRGtk2}


% The widgets described above, are also available through
% \pkg{gWidgetsRGtk2}. The two packages can be used together, for the
% most part. The \code{add} method of \pkg{gWidgetsRGtk2} can be used to
% add an \pkg{RGtk2} widget to a \code{gWidgetsRGtk2}
% container. Whereas, the \code{getToolkitWidget} method will (usually)
% return the \pkg{RGtk2} component to use within \pkg{RGtk2}.

%% Views example in next chapter?

\chapter{RGtk2: Windows, Containers, and Dialogs}
\label{sec:top-level-windows}
%% JV: 1/14/11: I moved this around following your comments after top
%% level windows: dialogs are now after box containers (as they are
%% needed for the example); discussion on other containers
%% follows. Then I moved the basic controls into a separate chapter,
%% as this one got rather long.




%% JV: 1/27/11 This intro para. needed a rewrite 
% This section covers some of the basic widgets and containers of
% \GTK. We begin with a discussion of top level containers and box
% containers. Then we describe many of the basic controls, and
% conclude with the mention of a few special-case containers.


This chapter covers top-level windows, dialogs and the container
objects provided by \GTK.

\section{Top-level windows}
\label{sec:RGtk2:gtkWindow}

%% constructor Show/Hide
As we saw in our ``Hello World'' example, top-level windows are
constructed by the \igui{top-level window}\constructor{gtkWindow} constructor. This function
has the argument \code{type} to specify the type of window to create. The
default is a top-level window, which we will always use, as the
alternative is for ``popups'' which are meant for internal use, e.g.,
for implementing menus. The second argument is \code{show}, which by
default is \code{TRUE}, indicating that the window should be shown. If
set to \code{FALSE}, the window, like other widgets, can later be
shown by calling its \method{show}{GtkWidget} method. The
\method{showAll}{GtkWidget} method will also show any child
components. These can be reversed with \method{hide}{GtkWidget} and
\method{hideAll}{GtkWidget}.

%% title
As with all objects, windows have several properties. The window title
is stored in the \code{title} property. As usual, this property can be
accessed via the ``get'' and ``set'' methods
\method{getTitle}{GtkWindow} and \method{setTitle}{gtkWindow}, or
using the \function{[} function. To illustrate, the following sets up
a new window with a title.
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show=FALSE)          # use default type
 window$setTitle("Window title")          # set window title
 window['title']                          # or  use getTitle
\end{Sinput}
\begin{Soutput}
[1] "Window title"
\end{Soutput}
\begin{Sinput}
 window$setDefaultSize(250,300)           # 250 wide, 300 high
 window$show()                            # show window
\end{Sinput}
\end{Schunk}

\paragraph{Window size}
The initial size of the window can be set with the
\method{setDefaultSize}{GtkWindow} method, as shown above, which takes a
\argument{width}{gtkWindow} and \argument{height}{gtkWindow} argument
specified in pixels. \ilayout{toplevel window size}This specification allows the window to be
resized but must be made before the window is drawn, as the window
then falls under control of the window manager. The
\method{setSizeRequest}{GtkWidget} method will request a minimum size,
which the window manager will usually honor, as long as a maximum
bound is not violated. To fix the size of a window, the
\code{resizable} property may be set to \code{FALSE}.

%% A container
\paragraph{Adding a child component to a window}
A window is a container. \class{GtkWindow} inherits from
\class{GtkBin}, which derives from \class{GtkContainer} and allows
only a single child. As before, this child is added through the
\method{add}{GtkContainer} method. 
We illustrate the basics by adding a simple label to a window.
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE); window$setTitle("Hello world")
 label <- gtkLabel("Hello world")
 window$add(label)
\end{Sinput}
\end{Schunk}
%
To display multiple widgets in a window, one simply needs to add a
non-\class{GtkBin} container as the child widget. We will discuss
additional container types in Section~\ref{sec:RGtk2:layout}.

%% delete-event; destroy
\paragraph{Destroying windows}
A window is normally closed by the window manager. Most often, this
occurs in response to the user clicking on a close button in a title
bar.  When this happens, the window manager requests that the window be deleted,
and the \code{delete-event} signal is emitted. As with any window
manager event, the default handler is overridden if a callback
connected to \code{delete-event} returns \code{TRUE}.  This can be
useful for confirming the intention of the user before closing the
window. For example:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(window, "delete-event", function(event) {
   dialog <- gtkMessageDialog(parent = window, flags = 0, 
                              type = "question", 
                              buttons = c("yes", "no"),
                              "Are you sure you want to quit?")
   dialog$run() != GtkResponseType["yes"]
 })
\end{Sinput}
\end{Schunk}
%
(We describe the use of message dialogs in
Section~\ref{sec:gtk-dialog-message}.) The contract of deletion is that
the window should no longer be visible on the screen. It is not
necessary for the actual window object to be removed from memory,
although this is the default behavior. Calling the \code{hideOnDelete}
method configures the window to hide but not destroy itself.

It is also possible to close a window programmatically by calling
its \method{destroy}{GtkWidget} method:
\begin{Schunk}
\begin{Sinput}
 window$destroy()
\end{Sinput}
\end{Schunk}

\paragraph{Transient windows}
New windows may be standalone top-level windows or may be associated
with some other window. For example, a dialog is usually associated
with the primary document window. The
\method{setTransientFor}{GtkWindow} method specifies the
window with which a transient (dialog) window is associated. This
hints to the window manager that the transient window should be kept on
top of its parent. The position relative to the parent window can be
specified with \code{setPostion}, which takes a value from the
\gtkenum{GtkWindowPosition} enumeration. Optionally, a dialog can be
set to be destroyed with its parent. For example:
\begin{Schunk}
\begin{Sinput}
 ## create a window and a dialog window
 window <- gtkWindow(show = FALSE)
 window$setTitle("Top level window")
 ##
 dialog <- gtkWindow(show = FALSE)
 dialog$setTitle("dialog window")
 dialog$setTransientFor(window)
 dialog$setPosition("center-on-parent")
 dialog$setDestroyWithParent(TRUE)
 window$show()
 dialog$show()
\end{Sinput}
\end{Schunk}
% 
The above code produces a non-modal dialog window from scratch. Due to
its transient nature, it can hide parts of the top-level window, but,
unlike a modal dialog, it does not prevent that window from receiving
events. \GTK\/ provides a number of convenient high-level dialogs,
discussed in Section~\ref{sec:dialogs}, that support modal operation.

\section{Layout containers}
\label{sec:RGtk2:layout}

Once a top-level window is constructed, it remains to fill the window
with the controls that will constitute our GUI. As these controls are
graphical, they must occupy a specific region on the screen. The
region could be specified as a fixed rectangle. However, as a
user interface, a GUI is dynamic and interactive. The size constraints
of widgets will change, and the window will be resized. The programmer
can ill afford to explicitly manage a dynamic layout. Thus, \GTK\/
implements automatic layout in the form of container widgets.

\subsection{Basics}
\label{sec:RGtk2:layout:basics}

In \GTK{}, the \iprogram{widget hierarchy}widget hierarchy is built
when children are added to a parent container.  In this example, a
window is made the parent of a label:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show=FALSE)
 window$setTitle("Hello world")
 label <- gtkLabel("Hello world")
 window$add(label)
\end{Sinput}
\end{Schunk}

The method \method{getChildren}{GtkContainer} will return the children
of a container as a list. Since in this case the list will be at most
length one, the \method{getChild}{GtkWidget} method may be more
convenient, as it directly returns the only child, if any. For
instance, to retrieve the label text one could do:
\begin{Schunk}
\begin{Sinput}
 window$getChild()['label']
\end{Sinput}
\begin{Soutput}
[1] "Hello world"
\end{Soutput}
\end{Schunk}
%% [[ for container
The \method{[[}{GObject} method 
%% ]]
accesses the child widgets by number, as a convenient wrapper
around the \method{getChildren}{GObject} method:
\begin{Schunk}
\begin{Sinput}
 window[[1]]['label']
\end{Sinput}
\begin{Soutput}
[1] "Hello world"
\end{Soutput}
\end{Schunk}
%
Conversely, the \code{getParent} method for \GTK\/ widgets will
return the parent container of a widget.

Every container supports removing a child with the
\method{remove}{GtkWidget} method. The child can later be re-added.
For instance
\begin{Schunk}
\begin{Sinput}
 window$remove(label)
 window$add(label)
\end{Sinput}
\end{Schunk}
% 
To remove a widget from the screen but not its container, use the
\method{hide}{GtkWidget} method on the widget. The
\method{reparent}{GtkWidget} method is a convenience for moving a
widget between containers that ensures the child is not
\iprogram{garbage collection}garbage
collected during the transition.\footnote{An object becomes available
  for garbage collection when it has no references to it, which can
  happen if it is removed from the parent container.}

\subsection{Widget size negotiation}
\label{sec:RGtk2:layout:size}

We have already seen perhaps the simplest automatic layout container,
\class{GtkBin}, which fills all of its space with its
child. Despite the apparent simplicity, there is a considerable amount
of logic for calculating the size of the widget on the screen. The
child will first inform the parent of its desired natural size. For
example, a label might ask for the dimensions necessary to display all
of its text. The container then decides whether to allocate the
requested size or to allocate more or less than the requested
amount. The child then consumes the allocated space. Consider the
previous example of adding a label to a window:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window$setTitle("Hello world")
 label <- gtkLabel("Hello world")
 window$add(label)
\end{Sinput}
\end{Schunk}

%% Oddly this is choking for me
% <<layout-window-show-first>>=
% <<basic-window-label>>
% @
%
The window is shown before the label is added, and the default size is
likely much larger than the space the label needs to display ``Hello
world''. However, as the window size is now controlled by the window
manager, \class{GtkWindow} will not adjust its size. Thus, the label
is allocated more space than it requires.
\begin{Schunk}
\begin{Sinput}
 label$getAllocation()$allocation
\end{Sinput}
\end{Schunk}
% ML: a bit of a hack, because the size is not correct during build
% Might just have to iterate the event loop, but this is easy:
\begin{Soutput}
     x      y  width height 
     0      0    200    200 
\end{Soutput}
%
If, however, we avoid showing the window until the label is added, the
window will size itself so that the label has its natural size:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE); window$setTitle("Hello world")
 label <- gtkLabel("Hello world")
 window$add(label)
 window$show()
 label$getAllocation()$allocation
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Soutput}
     x      y  width height 
     0      0     79     18 
\end{Soutput}
\end{Schunk}
%
One might notice that it is not possible to decrease the size of the
window further. This is due to \class{GtkLabel} asserting a minimum
size request that is sufficient to display its text. The
\method{setSizeRequest}{GtkWidget} sets a user-level minimum size 
request for any widget. It is obvious from the method name, however,
that this is still strictly a request. It may not be satisfied, for
example, if the maximum window size constraint of the window manager
is violated. More importantly, setting a minimum size request is
generally discouraged, as it decreases the flexibility of the layout.

Any non-trivial GUI will require a window containing multiple
widgets. Let us consider the case where the child of the window is
itself a container, with multiple children.  Essentially the same
negotiation process occurs between the container and its children (the
grandchildren of the window). The container calculates its size
request based on the requests of its children and communicates it to
the window. The size allocated to the container is then distributed to
the children according to its layout algorithm. This process is the
same for every level in the container hierarchy.

\subsection{Box containers}
\label{sec:RGtk2:layout:box}

The most commonly used multi-child container in \GTK\/ is the box
(implemented in class \class{GtkBox}) which \ilayout{box layout}packs its children as if
they were in a box. Instances of \class{GtkBox} are constructed by
\function{gtkHBox} or \function{gtkVBox}.  These produce horizontal or
vertical boxes, respectively. Each child widget is allocated a cell in
the box.  The cells are arranged in a single column (\class{GtkVBox})
or row (\class{GtkHBox}). This one dimensional stacking is usually all
that a layout requires. The child widgets can be containers
themselves, allowing for very flexible layouts. For special cases
where some widgets need to span multiple rows or columns and align
themselves in both dimensions, \GTK\/ provides the \class{GtkTable}
class, which is discussed later.  Many of the principles we discuss in
this section also apply to \class{GtkTable}.

Here we will explain and demonstrate the use of \class{GtkHBox}, the
general horizontal box layout container. \class{GtkVBox} can be used
exactly the same way; only the direction of stacking is different.
Figure~\ref{fig:packing} illustrates a sampling of the possible
layouts that are possible with a \class{GtkHBox}.

%% JV: Michael, I don't have this figure and am not sure what to put
%% here. Can you show me the code or a figure? THanks.
%% ML: I put the figure in here, but it's somewhat redundant with your
%% example. Could we adjust your example just to show padding? It
%% seems like we could get rid of the fourth row and add a row where
%% fill and expand are TRUE but padding is 10.
%% JV: We need to tighten this up, but your figure has a much better
%% layout. I'll put the two together as suggested, but keep your
%% frames and numbering. XXX TODO
\begin{figure}[h!tbp]
  \begin{center}
    \includegraphics[angle=90, width=.65\textwidth]{packing.png}
    \caption{\label{fig:packing}A screenshot demonstrating the effect
      of packing two buttons into \class{GtkHBox} instances using the
      \method{packStart}{GtkBox} method with different combinations of
      the \argument{expand}{gtkBoxPackStart} and
      \argument{fill}{gtkBoxPackStart} settings.  The effect of the
      \argument{homogeneous}{gtkBoxPackStart} spacing setting on the
      \class{GtkHBox} is also shown.}
  \end{center}
\end{figure}

The code for some of these layouts is presented here. We begin by
creating a \class{GtkHBox} widget. We pass \code{TRUE} for the first
parameter, \argument{homogeneous}{gtkHBox}. This means that the
horizontal allocation of the box will be evenly distributed between
the children.  The second parameter directs the box to leave 5 pixels
of space between each child.  The following code constructs the
\class{GtkHBox}:
\begin{Schunk}
\begin{Sinput}
 box <- gtkHBox(TRUE, 5)
\end{Sinput}
\end{Schunk}
The equal distribution of available space is strictly enforced; the
minimum size requirement of a homogeneous box is set such that the box
always satisfies this assertion, as well as the minimum size
requirements of its children.

The \method{packStart}{GtkBox} and \method{packEnd}{GtkBox} methods pack a
widget into a box against the left and right side (top and
bottom for a \class{GtkVBox}), respectively. For this explanation, we
restrict ourselves to \method{packStart}{GtkBox}, since
\method{packEnd}{GtkBox} works the same except for the
direction. Below, we pack two buttons, \code{button\_a} and
\code{button\_b} against the left side:
\begin{Schunk}
\begin{Sinput}
 button_a <- gtkButton("Button A")
 button_b <- gtkButton("Button B")
 box$packStart(button_a, fill = FALSE)
 box$packStart(button_b, fill = FALSE)
\end{Sinput}
\end{Schunk}
%
First, \code{button\_a} is packed against the left side of the box,
and then we pack \code{button\_b} against the right side of
\code{button\_a}. This results in the first row in
Figure~\ref{fig:packing}. The space distribution is homogeneous, but
making the space available to a child does not mean that the child
will fill it. That depends on the natural size of the child, as well
as the value of the \argument{fill}{gtkBoxPackStart} parameter passed
to \method{packStart}{GtkBox}. In this case,
\argument{fill}{gtkBoxPackStart} is \code{FALSE}, so the extra space
is not filled and the widget is aligned in the center of its
space. When a widget is packed with the
\argument{fill}{gtkBoxPackStart} parameter set to \code{TRUE}, the
widget is resized to consume the available space. This results in
rows~$2$ and $3$ in Figure~\ref{fig:packing}.

In many cases, it is desirable to give children unequal amounts of
available space, as in rows~4--9 in Figure~\ref{fig:packing}. 
To create a heterogeneously spaced \class{GtkHBox}, we pass
\code{FALSE} as the first argument to the constructor, as in the
following code:
\begin{Schunk}
\begin{Sinput}
 box <- gtkHBox(FALSE, 5)
\end{Sinput}
\end{Schunk}

A heterogeneous layout is freed of the restriction that all widgets
must be given the same amount of available space; it only needs to
ensure that each child has enough space to meet its minimum size
requirement. After satisfying this constraint, a box is often left
with extra space. The programmer may control the distribution of this
extra space through the \argument{expand}{gtkBoxPackStart} parameter
to \method{packStart}{GtkBox}.  When a widget is packed with
\argument{expand}{gtkBoxPackStart} set to \code{TRUE}, we will call
the widget an \emph{expanding} widget. All expanding widgets in a box
are given an equal portion of the entirety of the extra space. If no
widgets in a box are expanding, as in row~5 of
Figure~\ref{fig:packing}, the extra space is left undistributed. 

It is common to mix expanding and non-expanding widgets in the same
box.
% FIXME: do we use the mirror dialog example or another one?  For
% example, in the CRAN mirrors dialog, the box first ensures that the
% mirror list and the label above it are given enough space to satisfy
% their minimum requirement. Then, since the mirror list is expanding,
% all of the extra space is made available to it, while the label is
% left only with its minimum requirement (i.e., enough space to show
% its text).
An example is given below, where \code{button\_a} is expanding,
while \code{button\_b} is not:
%
\begin{Schunk}
\begin{Sinput}
 box$packStart(button_a, expand = TRUE, fill = FALSE)
 box$packStart(button_b, expand = FALSE, fill = FALSE)
\end{Sinput}
\end{Schunk}
%
The result is shown in row~6 of Figure~\ref{fig:packing}.  The figure
contains several other permutations of the
\argument{homogeneous}{gtkBoxPackStart},
\argument{expand}{gtkBoxPackStart} and
\argument{fill}{gtkBoxPackStart} settings.

\begin{figure}
  \centering
%%    \includegraphics[angle=90, height=.8\textheight, width=.75\textwidth]{packing.png} 
  \includegraphics[width=.8\textwidth]{ex-RGtk2-pack-start.png} 
  \caption{Examples of packing widgets into a box container. The top
    row shows no padding, whereas the 2nd and 3rd illustrate the
    difference between \code{padding} (an amount around each child)
    and \code{spacing} (an amount between each child). The last two
    rows show the effect of \code{fill} when \code{expand=TRUE}. This
    illustration follows one in the original \GTK\/ tutorial.}
  \label{fig:RGtk2-pack-start}
\end{figure}

\paragraph{Padding}
There are several ways to add space around widgets in a box container.
The \argument{spacing}{gtkHBox} argument for the constructors
specifies the amount of space, in pixels, between the cells. This
defaults to zero. The \code{pack} methods have a
\argument{padding}{gtkBoxPackStart} argument, also defaulting to zero,
for specifying the padding in pixels on either side of the child. It
is important to note the difference: \code{spacing} is between
children and the same for every boundary, while the \code{padding} is
specific to a particular child and occurs on either side, even on the
ends. The spacing between widgets is the sum of the \code{spacing}
value and the two \code{padding} values when the children are added.
Example~\ref{eg:RGtk2:mac-buttons} provides an example and
Figure~\ref{fig:RGtk2-pack-start} an illustration.

\paragraph{Positioning}
The \method{reorderChild}{GtkBox} method reorders the child
widgets. The new position of the child is specified using 0-based
indexing. This code will move the third child of \code{g} to the second position:
\begin{Schunk}
\begin{Sinput}
 b3 <- hbox[[3]]
 hbox$reorderChild(b3, 2 - 1)               # second is 2 - 1
\end{Sinput}
\end{Schunk}

\subsection{Alignment}
\label{sec:RGtk2:layout:align}

We began this section with a simple example of a window containing a
label:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window$setTitle("Hello world")
 label <- gtkLabel("Hello world")
 window$add(label)
\end{Sinput}
\end{Schunk}
%% again giving me issues
% <<basic-layout-align-window>>=
% <<basic-window-label>>
% @ 
%
The window allocates all of its space to the label, despite the actual
text consuming a much smaller region. The size of the text is fixed,
according to the font size, so it could not be expanded. Thus, the
label decided to center the text within itself (and thus the
window). A similar problem is faced by widgets displaying images. The
image cannot be expanded without distortion. Widgets that display
objects of fixed size inherit from \class{GtkMisc}, which provides
methods and properties for tweaking how the object is aligned within
the space of the widget. For example, the \code{xalign} and
\code{yalign} properties specify how the text is aligned in our label
and take values between $0$ and $1$, with $0$ being left and
top. Their defaults are $0.5$, for centered alignment. We modify them
below to make our label left justified:
\begin{Schunk}
\begin{Sinput}
 label["xalign"] <- 0
\end{Sinput}
\end{Schunk}
%% SCREENSHOT
Unlike a block of text or an image, a widget usually does not have a
fixed size. However, the user may wish to tweak how a widget fills
the space allocated by its container.  \GTK\/ provides the
\class{GtkAlignment} container for this purpose. For example, rather
than adjust the justification of the label text, we could have
instructed the layout not to expand but to position itself against the
left side of the window:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window$setTitle("Hello world")
 alignment <- gtkAlignment()
 alignment$set(xalign = 0, yalign = 0.5, xscale = 0, yscale = 1)
 window$add(alignment)
 label <- gtkLabel("Hello world")
 alignment$add(label)
\end{Sinput}
\end{Schunk}

\section{Dialogs}
\label{sec:dialogs}

\GTK\/ provides a number of convenient dialogs for the most common use
cases, as well as a general infrastructure for constructing custom
dialogs.  A dialog is a window that generally consists of an icon, a
content area, and an action area containing a row of buttons
representing the possible user responses.  Typically, a dialog belongs
to a main application window and might be modal, in which case input
is blocked to other parts of the GUI.  \class{GtkDialog}
represents a generic dialog and serves as the base class for all
special purpose dialogs in \GTK.

\igui{modal dialog}

\subsection{Message dialogs}
\label{sec:gtk-dialog-message}

Communicating textual messages to the user is perhaps the most common
application of a dialog. \GTK\/ provides the
\constructor{gtkMessageDialog} convenience wrapper for
\class{GtkDialog} for creating a message dialog showing a primary and
secondary message.  We construct one presently:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window['title'] <- "Parent window"
 #
 dialog <- gtkMessageDialog(parent=window, 
                            flags="destroy-with-parent",
                            type="question", 
                            buttons="ok",
                            "My message")
 dialog['secondary-text'] <- "A secondary message"
\end{Sinput}
\end{Schunk}
%

The \argument{flags}{gtkMessageDialog} argument allows one to specify
a combination of values from \code{GtkDialogFlags}. These include
\code{destroy-with-parent} and \code{modal}. Here, the dialog will be
destroyed upon destruction of the parent window. The
\argument{type}{gtkMessageDialog} argument specifies the message type,
using one of the $4$ values from \code{GtkMessageType}, which
determines the icon that is placed adjacent to the message text. The
\argument{buttons}{gtkMessageDialog} argument indicates the set of
response buttons with a value from \code{GtkButtonsType}. The
remaining arguments are pasted together into the primary message.  The
dialog has a \code{secondary-text} property that can be set to give a
secondary message.

Dialogs are optionally modal. Below, we enable modality by calling the
\method{run}{GtkDialog} method, which will additionally block the \R\/
session:
\begin{Schunk}
\begin{Sinput}
 response <- dialog$run()
 if(response == GtkResponseType["cancel"] || # for other buttons
    response == GtkResponseType["close"] ||
    response == GtkResponseType["delete-event"]) {
   ## pass
 } else if(response == GtkResponseType["ok"]) {
   message("Ok")
 }
 dialog$destroy()
\end{Sinput}
\end{Schunk}
%
The return value can then be inspected for the action, such as what
button was pressed. \class{GtkMessageDialog} will return response
codes from the \gtkenum{GtkResponseType} enumeration. We will see an
example of asynchronous response handling in the next section.

\subsection{Custom dialogs}
\label{sec:custom-dialogs}

%% SCREENSHOT 

The \constructor{gtkDialog} constructor returns a generic dialog
object which can be customized, in terms of its content and response
buttons.  Usually, a \class{GtkDialog} is constructed with
\constructor{gtkDialogNewWithButtons}, as a dialog almost always
contains a set of response buttons, such as \kbd{Ok}, \kbd{Yes},
\kbd{No} and \kbd{Cancel}.  In this example, we will create a simple
dialog showing a label and text entry:
\begin{Schunk}
\begin{Sinput}
 dialog <- gtkDialogNewWithButtons(title = "Enter a value", 
                        parent = NULL, flags = 0,
                        "gtk-ok", GtkResponseType["ok"],
                        "gtk-cancel", GtkResponseType["cancel"],
                        show = FALSE)
\end{Sinput}
\end{Schunk}
%
Buttons are added with a label and a response id, and their order is
taken from their order in the call. There is no automatic ordering
based on an operating system's conventions.  When the button label
matches a stock ID, the icon and text are taken from the stock
definition. We used standard responses from \code{GtkResponseType},
although in general the codes are simply integer values;
interpretation is up to the programmer.

The dialog has a content area, which is an instance of
\class{GtkVBox}. To complete our dialog, we place a labeled text entry
into the content area:
\begin{Schunk}
\begin{Sinput}
 hbox <- gtkHBox()
 hbox['spacing'] <- 10
 #
 hbox$packStart(gtkLabel("Enter a value:"))
 entry <- gtkEntry()
 hbox$packStart(entry)
 #
 vbox <- dialog$getContentArea()
 vbox$packStart(hbox)
\end{Sinput}
\end{Schunk}
%
The content is placed above the button box, with a separator between them.

In the message dialog example, we called the \method{run}{GtkDialog}
method to make the dialog modal. To make a non-modal dialog, do not
call \method{run}{GtkDialog} but connect to the \code{response} signal
of the modal dialog. The response code of the clicked button is passed
to the callback:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(dialog, "response", 
                f=function(dialog, response, user.data) {
                  if(response == GtkResponseType["ok"])
                    print(entry$getText()) # Replace this
                  dialog$Destroy()
                })
 dialog$showAll()
 dialog$setModal(TRUE)
\end{Sinput}
\end{Schunk}

\subsection{File chooser}
\label{sec:RGtk2:file-chooser}

A common task in a GUI is the selection of files and directories, for
example to load or save a document. \class{GtkFileChooser} is an
interface shared by widgets that choose files. \GTK\/ provides three
such widgets. The first is \class{GtkFileChooserWidget}, which may be
placed anywhere in a GUI. The other two are based on the
first. \class{GtkFileChooserDialog} embeds the chooser widget in a
modal dialog, while \class{GtkFileChooserButton} is a button that
displays a file path and launches the dialog when clicked.

\begin{example}{An open file dialog}{ex:RGtk2:open-file}
  Here, we demonstrate the use of the dialog, the most commonly used
  of the three.  An open file dialog can be created with:
\begin{Schunk}
\begin{Sinput}
 dialog <- gtkFileChooserDialog(title = "Open a file", 
                      parent = NULL, action = "open",
                      "gtk-ok", GtkResponseType["ok"],
                      "gtk-cancel", GtkResponseType["cancel"],
                      show = FALSE)
\end{Sinput}
\end{Schunk}
  % 
  The dialog constructor allows one to specify a title, a parent and an
  action, either \code{open}, \code{save}, \code{select-folder} or
  \code{create-folder}. In addition, the dialog buttons must be
  specified, as with the last example using
  \code{gtkDialogNewWithButtons}.

  We connect to the \signal{response} signal
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(dialog, "response", 
                f = function(dialog, response, data) {
                  if(response == GtkResponseType["ok"]) {
                    filename <- dialog$getFilename()
                    print(filename)
                  }
                  dialog$destroy()
                })
\end{Sinput}
\end{Schunk}
  % 
  The file selected is returned by
  \method{getFilename}{GtkFileChooser}. If multiple selection is enabled
  (via the \code{select-multiple} property) one should call the
  plural \method{getFilenames}{GtkFileChooser}.

  For the open dialog, one may wish to specify one or more filters that
  narrow the available files for selection:
\begin{Schunk}
\begin{Sinput}
 fileFilter <- gtkFileFilter()
 fileFilter$setName("R files")
 fileFilter$addPattern("*.R")
 fileFilter$addPattern("*.Rdata")
 dialog$addFilter(fileFilter)
\end{Sinput}
\end{Schunk}
  % 
  The \constructor{gtkFileFilter} function constructs a filter, which is
  given a name and a set of file name patterns, before being added to
  the file chooser. Filtering by MIME type is also supported.

\end{example}

The save file dialog would be similar. The initial filename could be
specified with \method{setFilename}{GtkFileChooser}, or folder with
\method{setFolder}{GtkFileChooser}. The
\code{do-overwrite-confirmation} property controls whether the user is
prompted when attempting to overwrite an existing file.

Other features not discussed here, include embedding of preview and
other custom widgets, and specifying shortcut folders.

\subsection{Other choosers}

There are several other types of dialogs for making common types of
selections. These include \code{GtkCalendar} for picking dates,
\code{GtkColorSelectionDialog} for choosing colors, and
\code{GtkFontSelectionDialog} for fonts. These are very high-level
dialogs that are trivial to construct and manipulate, at a cost of
flexibility.

\subsection{Print dialog}

Rendering documents for printing is outside our scope; however, we
will mention that \class{GtkPrintOperation} can launch the native,
platform-specific print dialog for customizing a printing
operation. See Example~\ref{eg:RGtk2:printing-graphics} for an example
of printing R graphics using \pkg{cairoDevice}.


\section{Special-purpose containers}
\label{sec:RGtk2:containers}

In Section~\ref{sec:RGtk2:layout}, we presented \class{GtkBox} and
\class{GtkAlignment}, the two most useful layout containers in
\GTK. This section introduces some other important containers. These
include the merely decorative \class{GtkFrame}; the interactive
\class{GtkExpander}, \class{GtkPaned} and \class{GtkNotebook}; and the
grid-style layout container \class{GtkTable}. All of these widgets are
derived from \class{GtkContainer}, and so share many methods.

\subsection{Framed containers}
\label{sec:RGtk2:gtkFrame}

The \constructor{gtkFrame} function constructs a container that draws
a decorative, labeled frame around its single child:
\begin{Schunk}
\begin{Sinput}
 frame <- gtkFrame("Options")
 vbox <- gtkVBox()
 vbox$packStart(gtkCheckButton("Option 1"), FALSE)
 vbox$packStart(gtkCheckButton("Option 2"), FALSE)
 frame$add(vbox)
\end{Sinput}
\end{Schunk}
%
A frame is useful for visually segregating a set of conceptually
related widgets from the rest of the GUI. The type of decorative
shadow is stored in the \code{shadow-type} property.  The
\method{setLabelAlign}{GtkFrame} aligns the label relative to the
frame. This is to the left, by default.

\subsection{Expandable containers}
\label{sec:RGtk2:gtkExpander}

The \class{GtkExpander} widget provides a button that hides and shows
a single child upon demand. This is often an effective mechanism for
managing screen space. Expandable containers are constructed by
\function{gtkExpander}:
\begin{Schunk}
\begin{Sinput}
 expander <- gtkExpander("Advanced")
 expander$add(frame)
\end{Sinput}
\end{Schunk}
%
Use \function{gtkExpanderNewWithMnemonic} if a mnemonic is desired.
The \code{expanded} property, which can be accessed with
\method{getExpanded}{GtkExpander} and
\method{setExpanded}{GtkExpander}, represents the visible state of the
widget.  When the \code{expanded} property changes, the
\signal{activate} signal is emitted.

\subsection{Notebooks}
\label{sec:RGtk2:gtkNotebook}

The \constructor{gtkNotebook} constructor creates a notebook
container, a widget that displays an array of buttons resembling
notebook tabs. Each tab corresponds to a widget, and when a tab is
selected, its widget is made visible, while the others are hidden. If
\class{GtkExpander} is like a check button, \class{GtkNotebook} is
like a radio button group. 

We create a notebook and add some pages:
\begin{Schunk}
\begin{Sinput}
 notebook <- gtkNotebook()
 notebook$appendPage(gtkLabel("Page 1"), gtkLabel("Tab 1"))
\end{Sinput}
\begin{Soutput}
[1] 0
\end{Soutput}
\begin{Sinput}
 notebook$appendPage(gtkLabel("Page 2"), gtkLabel("Tab 2"))
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\end{Schunk}
%
A page specification consists of a widget for the page and a widget
for the tab. Any type of widget is accepted, although a label is
typically used for the tab.  This flexibility allows for more complicated tabs,
such as a box container with a label and close icon.

The tabs can be positioned on any of the four sides of the notebook;
this depends on the \property{tab-pos}{gtkNotebook} property, with a value from
\gtkenum{GtkPositionType}: \qcode{left}, \qcode{right}, \qcode{top}, or
\qcode{bottom}. By default, the tabs are on top. We move the current ones to the
bottom:
\begin{Schunk}
\begin{Sinput}
 notebook['tab-pos'] <- "bottom"
\end{Sinput}
\end{Schunk}

Methods and properties that affect pages expect the page index,
instead of the page widget. To map from the child widget to the page
number, use the method \method{pageNum}{GtkNotebook}.  The
\property{page}{gtkNotebook} property holds the zero-based index of the active
tab. We make the second tab active:
\begin{Schunk}
\begin{Sinput}
 notebook['page'] <- 1
 notebook['page']
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\end{Schunk}
%
To move sequentially through the pages, call the methods
\method{nextPage}{GtkNotebook} and
\method{prevPage}{GtkNotebook}. When the current page changes, the
\signal{switch-page} signal is emitted.

Pages can be reordered using the \method{reorderChild}{GtkNotebook},
although it is usually desirable to allow the user to reorder
pages. The \method{setTabReorderable}{GtkNotebook} enables drag and
drop reordering for a specific tab. It is also possible for the user
to drag and drop pages between notebooks, as long as they belong to
the same group, which depends on the \prop{group-id}
property. Pages can be deleted using the method
\method{removePage}{GtkNotebook}.

\paragraph{Managing many pages}
By default, a notebook will request enough space to display all of its
tabs. If there are many tabs, space may be wasted. \class{GtkNotebook}
solves this with the scrolling idiom. If the
property \code{scrollable} is set to \code{TRUE}, arrows will be added
to allow the user to scroll through the tabs. In this case, the tabs
may become difficult to navigate. Setting the \code{enable-popup}
property to \code{TRUE} enables a right-click popup menu listing all
of the tabs for direct navigation.

\begin{example}{Adding a page with a close button}{eg:RGtk2-notebook-close-icon}
  A familiar element of notebooks in many web browsers is a tab close
  button. The following defines a new method
  \method{insertPageWithCloseButton}{GtkNotebook} that will use the
  themeable stock close icon.  The callback passes both the notebook
  and the page through the \code{data} argument, so that the proper
  page can be deleted.

  \begin{figure}
    \centering
    \includegraphics[width=.5\textwidth]{fig-RGtk2-notebook-close-buttons.png}
    \caption{Simple illustration of customized tab in a notebook. These include a close button.}
    \label{fig:RGtk2-notebook-close-buttons}
  \end{figure}
  
\begin{Schunk}
\begin{Sinput}
 gtkNotebookInsertPageWithCloseButton <- 
   function(object, child, label.text="", position=-1) {
     icon <- gtkImage(pixbuf = 
       object$renderIcon("gtk-close", "button", size = "menu"))
     closeButton <- gtkButton()
     closeButton$setImage(icon)
     closeButton$setRelief("none")
     ##
     label <- gtkHBox()
     label$packStart(gtkLabel(label.text))
     label$packEnd(closeButton)
     ##
     gSignalConnect(closeButton, "clicked", function(button) {
       index <- notebook$pageNum(child)
       notebook$removePage(index)
     })
     object$insertPage(child, label, position)
   }
\end{Sinput}
\end{Schunk}


Here is a simple demonstration of its usage:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow()
 notebook <- gtkNotebook(); window$add(notebook)
 notebook$insertPageWithCloseButton(gtkButton("hello"), 
                                    label.text = "page 1")
 notebook$insertPageWithCloseButton(gtkButton("world"), 
                                    label.text = "page 2")
\end{Sinput}
\end{Schunk}
  
\end{example}


\subsection{Scrollable windows}
\label{sec:RGtk2:scroll-windows}

The \class{GtkExpander} and \class{GtkNotebook} widgets support
efficient use of screen real estate. However, when a widget is always
too large to fit in a GUI, partial display is necessary. A
\class{GtkScrolledWindow} supports this by providing scrollbars for
the user to adjust the visible region of a single child. The range,
step and position of \class{GtkScrollbar} are controlled by an
instance of \class{GtkAdjustment}, just as with the slider and spin
button. Scrolled windows are most often used with potentially large
widgets like table views and when displaying images and graphics.

Our example will embed an R graphics device in a scrolled window and
allow the user to zoom in and out and pull on the scroll bars to pan
the view. First, we create an R graphics device using the
\pkg{cairoDevice} package
\begin{Schunk}
\begin{Sinput}
 library(cairoDevice)
 device <- gtkDrawingArea()
 device$setSizeRequest(600, 400)
 asCairoDevice(device)
\end{Sinput}
\end{Schunk}
%
and then embed it within a scrolled window
\begin{Schunk}
\begin{Sinput}
 scrolled <- gtkScrolledWindow()
 scrolled$addWithViewport(device)
\end{Sinput}
\end{Schunk}
%
The widget in a scrolled window must know how to display only a part
of itself, i.e., it must be scrollable. Some widgets, including
\class{GtkTreeView} and \class{GtkTextView}, have native scrolling
support. Other widgets, like our \class{GtkDrawingArea}, must be
embedded within the proxy \class{GtkViewport}. The
\class{GtkScrolledWindow} convenience method
\method{addWithViewport}{GtkScrolledWindow} allows the programmer to
skip the \class{GtkViewport} step.


Next, we define a function for scaling the plot:
\begin{Schunk}
\begin{Sinput}
 zoomPlot <- function(x = 2.0) {
   allocation <- device$getAllocation()$allocation
   device$setSizeRequest(allocation$width * x, 
                         allocation$height * x)
   updateAdjustment <- function(adjustment) {
     adjustment$setValue(x * adjustment$getValue() + 
                         (x - 1) * adjustment$getPageSize() / 2)
   }
   updateAdjustment(scrolled$getHadjustment())
   updateAdjustment(scrolled$getVadjustment())
 }
\end{Sinput}
\end{Schunk}
%
The function gets the current size allocation from the device, scales
it by \qcode{x} and requests the new size. It then scrolls the window
to preserve the center point. The state of each scroll bar is
represented by a \class{GtkAdjustment}.  We update the value of
the horizontal and vertical adjustments to scroll the window.  The
value of an adjustment corresponds to the left/top position of the
window, so we adjust by half the page size after scaling the value.

\igui{keystroke events}
We had key press events, so that pressing \kbd{+} zooms in and
pressing \kbd{-} zooms out:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(scrolled, "key-press-event", 
                function(scrolled, event) {
                  key <- event[["keyval"]]
                  if (key == GDK_plus)
                    zoomPlot(2.0)
                  else if (key == GDK_minus)
                    zoomPlot(0.5)
                  TRUE
                })
\end{Sinput}
\end{Schunk}

Despite its name, the scrolled window is not a top-level window. Thus,
it needs to be added to a top-level window:
\begin{Schunk}
\begin{Sinput}
 win <- gtkWindow(show = FALSE)
 win$add(scrolled)
 win$showAll()
\end{Sinput}
\end{Schunk}
 
Finally, a basic scatterplot is displayed in the viewer:
\begin{Schunk}
\begin{Sinput}
 plot(mpg ~ hp, data = mtcars)
\end{Sinput}
\end{Schunk}

The properties \code{hscrollbar-policy} and \code{vscrollbar-policy}
determine when the scrollbars are drawn. By default, they are always
drawn. The \qcode{automatic} value from the \code{GtkPolicyType}
enumeration draws the scrollbars only if needed, i.e, if the child
widget requests more space than can be allocated. The
\method{setPolicy}{GtkScrolledWindow} method allows both to be set at
once.

% \begin{example}{Scrolled window example}{eg:RGtk2:scrolled-window}
%   \SweaveInput{ex-RGtk2-scrolled-window}
% \end{example}

\subsection{Divided containers}
\label{sec:RGtk2:gtkPanedWindow}

The \constructor{gtkHPaned} and \constructor{gtkVPaned} constructors
create containers that contain two widgets, arranged horizontally or
vertically and separated by a divider displaying a handle allowing the
user to adjust the allocation of space between the child
components. We will demonstrate only the horizontal pane
\class{GtkHPaned} here, without loss of generality.
% An example is presented in Example \ref{eg:RGtk2:using-tree-content}. 

First, we construct an instance of \class{GtkHPaned}:
\begin{Schunk}
\begin{Sinput}
 paned <- gtkHPaned()
\end{Sinput}
\end{Schunk}

The two children may be added two different ways. The simplest
approach calls \method{add1}{GtkPaned} and
\method{add2}{GtkPaned} for adding the first and second child,
respectively. 
\begin{Schunk}
\begin{Sinput}
 paned$add1(gtkLabel("Left (1)"))
 paned$add2(gtkLabel("Right (2)"))
\end{Sinput}
\end{Schunk}
%
This configures the container such that both children are allowed to
shrink and only the second widget can expand. Such a configuration is
appropriate for a GUI with main widget and a side pane to the
left. More flexibility is afforded by the methods
\method{pack1}{GtkPaned} and \method{pack2}{GtkPaned}, which have
arguments for specifying whether the child should expand
(\qcode{resize}) and/or \qcode{shrink}. Here we add the children such
that both can expand and shrink:
\begin{Schunk}
\begin{Sinput}
 paned$pack1(gtkLabel("Left (1)"), resize = TRUE, shrink = TRUE)
 paned$pack2(gtkLabel("Right (2)"), resize = TRUE, shrink = TRUE)
\end{Sinput}
\end{Schunk}
%
After children are added, they can be retrieved from the container
through the \method{getChild1}{GtkPaned} and
\method{getChild2}{GtkPaned} methods.

The screen position of the handle can be set with the
\method{setPosition}{GtkPaned} method.  The properties
\code{min-position} and \code{max-position} are useful for converting
a percentage into a screen position. The \signal{move-handle} signal
is emitted when the handle position is changed.

\subsection{Tabular layout}
\label{sec:RGtk2:gtkTable}

\class{GtkTable} is a container for laying out objects in a tabular
(or grid) \ilayout{grid layout}format. It is \emph{not} meant for displaying tabular
data. The container divides its space into cells of a grid, and a
child widget may occupy one or more cells. The allocation of space
within a row or column follows logic similar to that of box
layouts. The most common use case of a \class{GtkTable} is a form
layout, which we will demonstrate in our example.

\begin{example}{Dialog layout}{ex-RGtk2-dialog-layout}
This example shows how to layout a form in a dialog with some
attention paid to how the widgets are aligned and how they respond to
resizing of the window.

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{fig-RGtk2-gtktable-example.png}
  \caption{A basic dialog using a \code{gtkTable} container for layout.}
  \label{fig:RGtk2-dialog-layout}
\end{figure}

Our form layout will require $3$ rows and $2$ columns:
\begin{Schunk}
\begin{Sinput}
 table <- gtkTable(rows = 3, columns = 2, homogeneous = FALSE)
\end{Sinput}
\end{Schunk}
%
By default, the cells are allowed to have different sizes. This may be
overridden by passing \qcode{homogeneous = TRUE} to the constructor,
which forces all cells to have the same size.

We construct the widgets that will be placed in the form:
\begin{Schunk}
\begin{Sinput}
 size_label <- gtkLabel("Sample size:")
 size_combo <- gtkComboBoxNewText()
 sapply(c(5, 10, 15, 30), size_combo$appendText)
 ##
 diag_label <- gtkLabel("Diagnostic:")
 diag_radio <- gtkVBox()
 radiogp <- list()
 radiogp$t <- gtkRadioButton(label = "t-statistic")
 radiogp$mean <- gtkRadioButton(radiogp, label = "mean")
 radiogp$median <- gtkRadioButton(radiogp, label = "median")
 sapply(radiogp, diag_radio$packStart)
 ##
 submit_vbox <- gtkVBox()
 submit_vbox$packEnd(gtkButton("Run simulation"), expand = FALSE)
\end{Sinput}
\end{Schunk}
%%
We align the labels to the right, up against their corresponding entry
widgets, which are left-aligned:
\begin{Schunk}
\begin{Sinput}
 size_label['xalign'] <- 1
 diag_label['xalign'] <- 1; diag_label['yalign'] <- 0
 diag_align <- gtkAlignment(xalign = 0)
 diag_align$add(diag_radio)
\end{Sinput}
\end{Schunk}
% 
The labels are aligned through the \class{GtkMisc} functionality
inherited by \class{GtkLabel}. The \class{GtkVBox} with the radio
buttons does not support this, so we have embedded it within a
\class{GtkAlignment} instance. We have aligned the diagnostic label to
the top of its cell; otherwise, it would have been  centered
vertically. The radio buttons are left aligned, up against the label
(cf. Figure~\ref{fig:RGtk2-dialog-layout}).

Child widgets are added to a \class{GtkTable} instance through its
\method{attach}{GtkTable} method.  The child can span more than one
cell. The arguments \argument{left.attach}{gtkTableAttach} and
\argument{right.attach}{gtkTableAttach} specify the horizontal bounds
of the child in terms of its left column and right column,
respectively. Analogously, \argument{top.attach}{gtkTableAttach} and
\argument{bottom.attach}{gtkTableAttach} define the vertical bounds.
By default, the widgets will expand into and fill the available space,
much as if \argument{expand}{gtkBoxPackStart} and
\argument{fill}{gtkBoxPackStart} were passed as \code{TRUE} to
\method{packStart}{GtkBox} (see
Section~\ref{sec:RGtk2:layout:box}). There is no padding between
children by default. Both the resizing behavior and padding may be
overridden by specifying additional arguments to
\method{attach}{GtkTable}.

The following attaches the combo box, radio buttons and their labels
to the table:
\begin{Schunk}
\begin{Sinput}
 table$attach(size_label, left.attach = 0,1, top.attach = 0,1, 
              xoptions = c("expand", "fill"), yoptions = "")
 table$attach(size_combo, left.attach = 1,2, top.attach = 0,1, 
              xoptions = "fill", yoptions = "")
 ##
 table$attach(diag_label, left.attach = 0,1, top.attach = 1,2, 
              xoptions = c("expand", "fill"), 
              yoptions = c("expand", "fill"))
 ##
 table$attach(diag_align, left.attach = 1,2, top.attach = 1,2, 
              xoptions = c("expand", "fill"), yoptions = "")
 ##
 table$attach(submit_vbox, left.attach = 1,2, top.attach = 2,3, 
              xoptions = "", yoptions = c("expand", "fill"))
\end{Sinput}
\end{Schunk}
%
The labels are allowed to expand and fill in the $x$ direction,
because correct alignment, to the right, requires them to have the
same size. The combo box is instructed to fill its space, as it would
otherwise be undesirably small, due to its short menu items. 

One can add spacing to the right of cells in a particular row or
column. Here we add $5$ pixels of space to the right of the label
column:
\begin{Schunk}
\begin{Sinput}
 table$setColSpacing(0, 5)
\end{Sinput}
\end{Schunk}

We complete the example by placing the table into a window:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show=FALSE)
 window['border-width'] <- 14
 window$setTitle("GtkTable Example")
 window$add(table)
\end{Sinput}
\end{Schunk}

\end{example}


\chapter{RGtk2: Basic Components}
\label{sec:basic-components}
In this chapter we cover many of the basic controls of \GTK.

\section{Buttons}
\label{sec:RGtk2:gtkButton}

The button is the very essence of a GUI. It communicates its purpose
to the user and executes a command in response to a simple click or
key press. In \GTK\/, a basic button is usually constructed using
\constructor{gtkButton}, as the following example demonstrates.

\begin{example}{Button constructors}{eg:RGtk2:button-constructors}
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE)
 window$setTitle("Various buttons")
 window$setDefaultSize(400, 25)
 hbox <- gtkHBox(homogeneous = FALSE, spacing = 5)
 window$add(hbox)
 button <- gtkButtonNew() 
 button$setLabel("long way")
 hbox$packStart(button)
 hbox$packStart(gtkButton(label = "label only") )
 hbox$packStart(gtkButton(stock.id = "hboxtk-ok") )
 hbox$packStart(gtkButtonNewWithMnemonic("_Mnemonic") )
 window$show()
\end{Sinput}
\end{Schunk}
\end{example}

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{RGtk2-various-button}
  \caption{Various buttons}
  \label{fig:RGtk2:various-buttons}
\end{figure}

A \class{GtkButton} is simply a clickable region on the screen that is
rendered as a button. \class{GtkButton} is a subclass of
\class{GtkBin}, so it will accept any widget as an indicator of its
purpose. By far the most common button decoration is a label. The
first argument of \constructor{gtkButton},
\argument{label}{gtkButton}, accepts the text for an automatically
created \class{GtkLabel}. We have seen this usage in our ``Hello
World'' example and others.

Passing the \argument{stock.id}{gtkButton} argument to
\function{gtkButton} will use decorations associated with a so-called
\igui{stock icons}stock identifier, see Section~\ref{sec:RGtk2:stock-icons}. For
example, ``gtk-ok'' would produce a button with a theme-dependent
image (such as a checkmark) and the ``Ok'' label, with the appropriate
mnemonic (see below) and language translation.  The available stock
identifiers are listed by \function{gtkStockListIds}.

The \constructor{gtkButtonNewWithMnemonic} constructor creates a
button with a mnemonic. A mnemonic is a key press that will activate
the button and is indicated by prefixing the character with an
underscore. In our example, we pass the string ``\_Mnemonic'', so
pressing \kbd{Alt-M} will effectively press the button.

%% signals
\paragraph{Signals}

The \signal{clicked} signal is emitted when the button is clicked with
the mouse, when the associated mnemonic is pressed or when the button
has focus and the \kbd{enter} key is pressed. A callback can listen
for this event to perform a command when the button is clicked.

\begin{example}{Callback example for
    \code{gtkButton}}{eg:RGtk2:gtkButton-callback}

\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); button <- gtkButton("click me");
 window$add(button)
 gSignalConnect(button, "button-press-event", # just mouse
                f = function(widget, event, data) {
                  print(event$getButton())    # which button
                  return(FALSE)               # propagate
                })
 gSignalConnect(button, "clicked",            # keyboard too
                f = function(widget, ...) {
                  print("clicked")
                })
\end{Sinput}
\end{Schunk}
\end{example}

As buttons are intended to call an action immediately after being
clicked, it is advisable to make them insensitive to user input when
the action is not possible. For example, we  set our button to be
insensitive through: 
\begin{Schunk}
\begin{Sinput}
 button$setSensitive(FALSE)
\end{Sinput}
\end{Schunk}

%% Buttons initiate actions
Windows often have a default action. For example, if a window contains
a form, the default action submits the form. If a button
executes the default action for the window, the button can be
set so that it is activated when the user presses \kbd{enter} while
the parent window has the focus. To implement this, the property
\code{can-default} must be \code{TRUE} and the widget method
\method{grabDefault}{GtkWidget} must be called. (This is not specific
to buttons, but any widget that can be activatable.) The
\class{GtkDialog} widget and its derivatives facilitate the use of
buttons in this manner, see Section~\ref{sec:dialogs}.

If the action that a button initiates is to be represented elsewhere
in the GUI, say a menubar, then a \code{GtkAction} object may be
appropriate. Action objects are covered in
Section~\ref{sec:RGtk2:UIManager}.

\begin{example}{Spacing between buttons}{eg:RGtk2:mac-buttons}
This example shows how to pack buttons into a box so that the spacing
between the similar buttons is 12 pixels, while potentially dangerous
buttons are separated from the rest by 24 pixels, as per the Apple human
interface guidelines.  

\GTK\/ provides the widget \class{GtkHButtonBox} for organizing
buttons in a manner consistent across an application. However, the
default layout modes would not yield the desired spacing. As such, we
will illustrate how to customize the spacing.  We assume that our
parent container, \code{hbox}, is a horizontal box container.


\begin{figure}
  \centering
  \includegraphics[width=.85\textwidth]{ex-RGtk2-mac-buttons}
  \caption{Example using stock buttons with extra spacing added between the \code{delete} and \code{cancel} buttons.}
  \label{fig:ex-RGtk2-mac-buttons}
\end{figure}

We include standard buttons, so we use the stock names and icons.
\begin{Schunk}
\begin{Sinput}
 ok <- gtkButton(stock.id="gtk-ok")
 cancel <- gtkButton(stock.id="gtk-cancel")
 delete <- gtkButton(stock.id="gtk-delete")
\end{Sinput}
\end{Schunk}

We specify the padding as we pack the widgets into the box, from right
to left, with \method{packEnd}{GtkBox}:
\begin{Schunk}
\begin{Sinput}
 hbox$packEnd(ok, padding = 0)
 hbox$packEnd(cancel, padding = 12)
 hbox$packEnd(delete, padding = 12)
 hbox$packEnd(gtkLabel(""), expand = TRUE, fill = TRUE) # a spring
\end{Sinput}
\end{Schunk}
%
The padding occurs to the left and right of the child.  The \code{ok}
button is given no padding. The \code{cancel} button is packed with 12
pixels of spacing, which separates it from the \code{ok}
button. Recognizing the \code{delete} button as potentially
irreversible, we add 12 pixels of separation between it and the
\code{cancel} button, for a total of 24 pixels. The blank label pushes
the buttons against the right side of the box.~\ilayout{springs}  We instruct the
\code{ok} button to grab focus, so that it becomes the default
button:
\begin{Schunk}
\begin{Sinput}
 ok$grabFocus()
\end{Sinput}
\end{Schunk}






\end{example}

\section{Static text and images}

\subsection{Labels}
\label{sec:RGtk2:gtkLabel}

The primary purpose of a label is to communicate the role of another
widget, as we showed for the button. Labels are created by the
\constructor{gtkLabel} constructor, which takes the label text as its
first argument. This text can be set with either
\method{setLabel}{GtkLabel} or \method{setText}{GtkLabel} and
retrieved with either \method{getLabel}{GtkLabel} or
\method{getText}{GtkLabel}.  The difference being the former
respects formatting marks.

\begin{example}{Label formatting}{eg:RGtk2:label-formatting}
  As most text in a \GTK\/ GUI is ultimately displayed by
  \class{GtkLabel}, there are many formatting options available.  This
  example demonstrates a sample of
  these~(Figure~\ref{fig:RGtk2:label-formatting})
  
  \begin{figure}
    \centering
    \includegraphics[width=.5\textwidth]{fig-RGtk2-labels}
    \caption{Various formatting for a label: wrapping, alignment,
      ellipsizing, Pango markup}
    \label{fig:RGtk2:label-formatting}
  \end{figure}
  
\begin{Schunk}
\begin{Sinput}
 string <- "the quick brown fox jumped over the lazy dog"
 ## wrap by setting number of characters
 basicLabel <- gtkLabel(string)
 basicLabel$setLineWrap(TRUE)
 basicLabel$setWidthChars(35)            # no. characters
 ## Set ellipsis to shorten long text
 ellipsized <- gtkLabel(string)
 ellipsized$setEllipsize("middle")
 ## Right justify text lines
 ## use xalign property for aligning entire block
 rightJustified <- gtkLabel("right justify")
 rightJustified$setJustify("right")
 rightJustified['xalign'] <- 1
 ## PANGO markup
 pangoLabel <- gtkLabel()
 tmpl <- "<span foreground='blue' size='x-small'>%s</span>"
 pangoLabel$setMarkup(sprintf(tmpl, string))
 #
 sapply(list(basicLabel, ellipsized, rightJustified, pangoLabel), 
        vbox$packStart, expand = TRUE, fill = TRUE)
 window$showAll()
\end{Sinput}
\end{Schunk}
\end{example}

Many of the text formatting options are demonstrated in
Example~\ref{eg:RGtk2:label-formatting}. Line wrapping is enabled with
\method{setLineWrap}{GtkLabel}. Labels also support explicit line
breaks, specified with ``\code{\backslashn}.'' The
\method{setWidthChars}{GtkLabel} method is a convenience for instructing the
label to request enough space to show a specified number of
characters in a line.  When space is at a premium, long labels can be
ellipsized, i.e., have some of their text replaced with an
ellipsis, ``...''.  By default this is turned off; to enable, call
\method{setEllipsize}{GtkLabel}.  The property \code{justify}, with
values taken from \code{GtkJustification}, controls the alignment of
multiple lines within a label. To align the entire block of text
within the space allocated to the label, modify the \code{xalign}
property, as described in Section~\ref{sec:RGtk2:layout:align}.

\iprogram{text markup}
\paragraph{Pango markup}
\GTK\/ allows markup of text elements using the \defn{Pango} text attribute
markup language, an XML-based format that resembles basic HTML. The
method \method{setMarkup}{GtkLabel} accepts text in the format. Text
is marked using tags to indicate the style. Some convenient tags are
\code{<b>} for bold, \code{<i>} for italics, \code{<ul>} for
underline, and \code{<tt>} for monospace text. Hyperlinks are possible
with \code{<a>}, as of version 2.18, and similar logic to
\function{browseURL} is implemented for launching a web
browser. Connect to the \signal{activate\_link} signal to
override it. More complicated markup involves the \code{<span>} tag
markup, such as \code{<span color='red'>some text</span>}. As with
HTML, the text may need to be escaped first so that designated
entities replace reserved characters.

Although mostly meant for static text display, \class{GtkLabel} has
some interactive features. If the \code{selectable} property is set to
\code{TRUE}, the text can be selected and copied into the clipboard.
Labels can hold mnemonics for other widgets; this is useful for
navigating forms. The mnemonic is specified at construction time with
\code{gtkLabelNewWithMnemonic}. The
\method{setMnemonicWidget}{GtkLabel} method identifies the widget to
which the mnemonic refers.

For efficiency reasons \class{GtkLabel} does not receive any input
events. It lacks an underlying \class{GdkWindow}, meaning that there
are no window system resources allocated for receiving the
events. Thus, to make a label interactive, one must first embed it
within a \class{GtkEventBox}, which provides the \class{GdkWindow}.

\subsection{Images}
\label{sec:RGtk2:images}

It is often said that a picture can be worth a thousand
words. Applying this to a GUI, good images can be worth a thousand
pixels, as they can compactly represent ideas and actions. \class{GtkImage} is the widget that
displays images. The constructor \constructor{gtkImage} creates images
from various in-memory image representations, files, and other
sources.  Images can be loaded after construction, as well. For
example, the \method{setFromFile}{GtkImage} method loads an image from
a file.

\begin{example}{Using a pixmap to present graphs}{ex:RGtk2:pixbuf}

  This example shows how to use a \class{GtkImage} object to
  embed a graphic within \pkg{RGtk2}, using the
  \pkg{cairoDevice} package. The basic idea is to draw onto an
  off-screen pixmap using \pkg{cairoDevice} and
  then to construct a \class{GtkImage} from the pixmap. 

  We begin by creating a window of a certain size.
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE)
 window$setTitle("Graphic window")
 window$setSizeRequest(400,400)
 hbox <- gtkHBox(); window$add(hbox)
 window$showAll()
\end{Sinput}
\end{Schunk}


The size of the image is taken as the size allocated to the box
\code{hbox}. This allows the window to be resized prior to drawing the
graphic. Unlike an interactive device, after drawing, this graphic
does not resize itself when the window resizes.
\begin{Schunk}
\begin{Sinput}
 theSize <- hbox$getAllocation()$allocation
 width <- theSize$width; height <- theSize$height
\end{Sinput}
\end{Schunk}

We create a \class{GdkPixmap} of the correct dimensions and
initialize an R graphics device that targets the pixmap. A simple
histogram is then plotted using base R graphics.
\begin{Schunk}
\begin{Sinput}
 require(cairoDevice)
 pixmap <- gdkPixmap(drawable = NULL, 
                     width = width, height = height, depth = 24)
 asCairoDevice(pixmap)
 hist(rnorm(100))
\end{Sinput}
\end{Schunk}

The final step is to create the \class{GtkImage} widget to display the
pixmap: 
\begin{Schunk}
\begin{Sinput}
 image <- gtkImage(pixmap = pixmap)
 hbox$packStart(image, expand = TRUE, fill = TRUE)
\end{Sinput}
\end{Schunk}

\end{example}


The image widget, like the label widget, does not have a parent
\class{GdkWindow}, which means it does not receive window events. As
with the label widget, the image widget can be placed inside a
\class{GtkEventBox} container if one wishes to connect to such
events.

\subsection{Stock icons}
\label{sec:RGtk2:stock-icons}

In \GTK\/, standard icons, like the one on the ``OK'' button, can be
customized by themes. This is implemented by a database that maps a
\textit{stock} identifier to an icon image. The stock identifier
corresponds to a commonly performed type of action, such as the ``OK''
response or the ``Save'' operation. There is no hard-coded set of
stock identifiers, however \GTK\/ provides a default set for the most
common operations. These identifiers are all prefixed with
``gtk-''. Users may register new types of stock icons.
%% ML: I believe there is an example of this in the RGtk2 demos

As mentioned previously, the full list of stock icons are returned in
a list by \function{gtkStockListIds}. The first $3$ are:
\begin{Schunk}
\begin{Sinput}
 head(unlist(gtkStockListIds()), n=3)   
\end{Sinput}
\begin{Soutput}
[1] "gtk-zoom-out" "gtk-zoom-in"  "gtk-zoom-fit"
\end{Soutput}
\end{Schunk}

The use of stock identifiers over specific images is encouraged, as it
allows an application to be customized through themes. The
\constructor{gtkButton} and \constructor{gtkImage} constructors accept
a stock identifier passed as \code{stock.id} argument, and the icons in
toolbars and menus are most conveniently specified by a stock
identifier. 

% ML: Sorry, but I am not sure if this illustrates an important concept


% In the example below, we use the method \method{renderIcon}{gtkWidget} to
% return a pixbuf containing the icon that can be used with the
% constructor \constructor{gtkImageNewFromPixbuf} to display the
% icon. Here the stock id and size are specified to the
% \method{renderIcon}{gtkWidget} method.

% \begin{example}{\constructor{gtkButtonNewFromStock} -- the hard way}{ex:RGtk2:stock-icon}
% \SweaveInput{ex-RGtk2-button-new-stock-hardway}
% \end{example}

% ML: Could this example be in the book, but marked as optional or advanced?
%% JV Only for the package?? This will be placed in the package as an example.
% \begin{example}{Adding to the stock icons}{ex:RGtk2:add-stock-icons}
%   \SweaveInput{ex-RGtk2-add-stock-icon}
% \end{example}



%% Alertpanel application 
%% JV replaced this with one using reference Classes 
%% JV: This shows event boxes and reference classes, not a bad
%% thing but otherwise is just an info bar which isnow added. Should
%% we comment out?
%% ML: this is a fairly complicated example for a concept that is not
%% so important (GtkEventBox). I don't see how it's useful for
%% show/hide, which are pretty obvious.
%% JV: killed
% \begin{example}{An alert panel}{eg:RGtk2:alert-panel}
%   \SweaveInput{ex-RGtk2-alert-panel-2}
% \end{example}

\section{Input controls}

\subsection{Text entry}
\label{sec:RGtk2:gtkEntry}

The widgets explained thus far are largely static, i.e., it is not
possible to edit a label or image. \GTK\/ has two different widgets
for editing text. One is optimized for multi-line text documents, the
other for single line entry. We will discuss complex multi-line text
editing in Section~\ref{sec:RGtk2:textviews}. For entering a single
line of text, the \class{GtkEntry} widget is appropriate:
\begin{Schunk}
\begin{Sinput}
 entry <- gtkEntry()
\end{Sinput}
\end{Schunk}

The \code{text} property stores the text. This can be set with the
method \method{setText}{GtkEntry} and retrieved with
\method{getText}{GtkEntry}.  When the user has committed an entry,
e.g. by pressing the \kbd{enter} key, the \signal{activate} signal is
emitted. Here we connect to this signal to obtain the entered text upon
activation:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(entry, "activate", function() {
   message("Text entered: ", entry$getText())
 })
\end{Sinput}
\end{Schunk}

Sometimes the length of the text needs to be constrained to some
number of characters. The \argument{max}{gtkEntry} argument to
\function{gtkEntry} specifies this, but that usage is
deprecated. Instead, one should call \method{setMaxLength}{GtkEntry}.

\paragraph{The \class{GtkEditable} interface}

Editing text programmatically relies on the \class{GtkEditable}
interface, which \class{GtkEntry} implements. The method
% ML: any way to prevent line wrapping in method names?
\method{insertText}{GtkEditable} inserts text before a position
specified by a $0$-based index. The return value is a list with the
component \code{position} indicating the position \textit{after} the
new text. The \method{deleteText}{GtkEditable} method deletes text
between two positions.

%% JV: This needs a better example
% The example shows how to insert and then delete text:
% <<InsertDeleteText>>=
% e$setText("Where did that guy go?")
% add.pos <- regexpr("guy", e['text']) - 1 # before "guy"
% ret <- e$insertText("@$#%! ", position = add.pos)
% e$getText()                             # or e['text']
% e$deleteText(start = add.pos, end = ret$position)
% e$getText()
% @
% % 

The \class{GtkEditable} interface supports three signals:
\signal{changed} when text is changed, \signal{delete-text} for delete
events, and \signal{insert-text} for insert events. It is possible to
prevent the insertion or deletion of text by connecting to the
corresponding signal and stopping the signal propagation with
\function{gSignalStopEmission}. 

\paragraph{Advanced \class{GtkEntry} features}

\class{GtkEntry} has a number of features beyond basic text entry,
including: completion, buffer sharing, icons, and progress
reporting. We discuss completion in
Section~\ref{sec:RGtk2:entry-completion} and shared buffers in
Section~\ref{sec:RGtk2:buffer-sharing}. The progress reporting API,
introduced with version $2.16$, is virtually identical to that of
\class{GtkProgressBar}, introduced in
Section~\ref{sec:progress-bars}. We treat icons here. This feature has
been present since version $2.16$.

\begin{figure}
  \centering
  \begin{minipage}[c]{.45\linewidth}
    \includegraphics[width=\textwidth]{fig-RGtk2-valid-entry.png}\quad
 \end{minipage}\quad
 \begin{minipage}[c]{.45\linewidth}
   \includegraphics[width=\textwidth]{fig-RGtk2-invalid-entry.png}
 \end{minipage}
 \caption{Illustration of adding an icon to a \class{GtkEntry} instance to indicate if the text entered is valid or not}
  \label{fig:RGtk2-valid-gtkentry}
\end{figure}


One can set an icon on an entry from a \class{GdkPixbuf}, stock ID,
icon name, or \class{GIcon}
(Figure~\ref{fig:RGtk2-valid-gtkentry}). Two icons are possible, one
at the beginning (\code{primary}) and one at the end
(\code{secondary}). A common use would be to place a search icon in an
entry widget, were it used for searching. In our example below, an
entry might listen to its input and update its icon to indicate
whether the entered text is valid (in this case, consisting only of
letters):

\iprogram{validation}
\begin{Schunk}
\begin{Sinput}
 validatedEntry <- gtkEntry()
 gSignalConnect(validatedEntry, "changed", function(entry) {
   text <- entry$getText()
   if (nzchar(gsub("[a-zA-Z]", "", text))) {
     entry$setIconFromStock("primary", "gtk-no")
     validatedEntry$setIconTooltipText("primary", 
                                  "Only letters are allowed")
   } else { 
     entry$setIconFromStock("primary", "gtk-yes")
     validatedEntry$setIconTooltipText("primary", NULL)
   }
 })
 validatedEntry$setIconFromStock("primary", "gtk-yes")
\end{Sinput}
\end{Schunk}
%
We add a tooltip on the error icon to indicate the nature of the
problem to the user. Icons can also be made clickable and used as a
source for drag and drop operations.

\subsection{Check button}
\label{sec:RGtk2:gtkCheckbox}

Very often, the action performed by a button simply changes the value
of a state variable in the application. \GTK\/ defines several types
of buttons that explicitly manage and display one aspect of the
application state. The simplest type of state variable is binary
(boolean) and is usually proxied by a \class{GtkCheckButton}.

A \class{GtkCheckButton} is constructed by
\function{gtkCheckButton}:
\begin{Schunk}
\begin{Sinput}
 checkButton <- gtkCheckButton("Option")
\end{Sinput}
\end{Schunk}
%
The state of the binary variable is represented by the
\code{active} property. We check our button:
\begin{Schunk}
\begin{Sinput}
 checkButton['active']
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\begin{Sinput}
 checkButton['active'] <- TRUE
\end{Sinput}
\end{Schunk}

When the state is changed the \signal{toggle} signal is emitted. The
callback should check the \code{active} property to determine if the
button has been enabled or disabled:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(checkButton, "toggled", function(button) {
   state <- ifelse(button$active, "active","inactive")
   message("Button is ", state)
 })
\end{Sinput}
\end{Schunk}

An alternative to \class{GtkCheckButton} is the lesser used
\class{GtkToggleButton}, which is actually the parent class of
\class{GtkCheckButton}. A toggle button is drawn as an ordinary
button. It is drawn as depressed while the state variable is \code{TRUE},
instead of relying on a check box to communicate the binary value.

\subsection{Radio button groups}
\label{sec:RGtk2:gtkRadioButton}

\GTK\/ provides two widgets for discrete state variables that accept
more than two possible values: combo boxes, discussed in the next
section, and radio buttons. The \function{gtkRadioButton} constructor
creates an instance of \class{GtkRadioButton}, an extension of
\class{GtkCheckButton}. Each radio button belongs to a group and only
one button in a group may be active at once.

\begin{example}{Basic radio button usage}{eg:gtk:radio-group-group-list} 
  When we construct a radio button, we need to add it to a
  group. There is no explicit group object; rather, the buttons are
  chained together as a linked list. By default, a newly constructed
  button is added to its own group. If the group list is passed to the
  constructor, the newly created button is added to the group:
\begin{Schunk}
\begin{Sinput}
 labels <- c("two.sided", "less", "greater")
 radiogp <- list()                           # list for group
 radiogp[[labels[1]]] <- gtkRadioButton(label=labels[1]) 
 for(label in labels[-1]) 
   radiogp[[label]] <- gtkRadioButton(radiogp, label=label)
\end{Sinput}
\end{Schunk}
%
As a convenience, there are constructor functions ending with
\code{FromWidget} that determine the group from a radio button
belonging to the group. As we will see in our second example, this
allows for a more natural \function{sapply} idiom that avoids the need
to allocate a list and populate it in a \code{for} loop.

We add each button to a vertical box:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window$setTitle("Radio group example")
 vbox <- gtkVBox(FALSE, 5); window$add(vbox)
 sapply(radiogp, gtkBoxPackStart, object = vbox)
\end{Sinput}
\end{Schunk}

We can set and query which button is active:
\begin{Schunk}
\begin{Sinput}
 vbox[[3]]$setActive(TRUE)           
 sapply(radiogp, `[`, "active") 
\end{Sinput}
\begin{Soutput}
two.sided      less   greater 
    FALSE     FALSE      TRUE 
\end{Soutput}
\end{Schunk}

The \code{toggle} signal is emitted when a button is toggled. We need
to connect a handler to each button:
\begin{Schunk}
\begin{Sinput}
 sapply(radiogp, gSignalConnect, "toggled",     # connect each
        f = function(button, data) {
          if(button['active']) # set before callback
            message("clicked", button$getLabel(),"\n")
        })
\end{Sinput}
\end{Schunk}
\end{example}

\begin{example}{Radio group via a \function{FromWidget}
    constructor}{eg:gtk:radio-group-get-group}
  In this example, we illustrate using the
  \constructor{gtkRadioButtonNewWithLabelFromWidget} function to add
  new buttons to the group:
\begin{Schunk}
\begin{Sinput}
 radiogp <- gtkRadioButton(label=labels[1])
 btns <- sapply(labels[-1], gtkRadioButtonNewWithLabelFromWidget, 
                group = radiogp)
 window <- gtkWindow()
 window['title'] <- "Radio group example"
 vbox <- gtkVBox(); window$add(vbox)
 sapply(rev(radiogp$getGroup()), gtkBoxPackStart, object = vbox)
\end{Sinput}
\end{Schunk}
%
The \method{getGroup}{GtkRadioButton} method returns a list containing
the radio buttons in the same group. However, it is in the reverse
order of construction (newest first). This results from an internal
optimization that prepends, rather than appends, the buttons to a
linked list. Thus, we need to call \function{rev} to reverse the list
before packing the widgets into the box.

\end{example}

\subsection{Combo boxes}
\label{sec:RGtk2:basic-combobox}

The combo box is a more space efficient alternative to radio buttons
and is better suited when there are a large number of options. A
basic, text-only \class{GtkComboBox} is constructed by
\constructor{gtkComboBoxNewText}. In
Section~\ref{sec:RGtk2:mvc:combobox} we will discuss combo boxes that
are based on an external data model.

We can construct and populate a simple combo box with:
\begin{Schunk}
\begin{Sinput}
 combo <- gtkComboBoxNewText()
 sapply(c("two.sided", "less", "greater"), combo$appendText)
\end{Sinput}
\end{Schunk}
%

The index of the currently active item is stored in the
\property{active}{gtkComboBox} property. The index, as usual, is $0$-based,
and a value of $-1$ indicates that no value is selected (the default):
\begin{Schunk}
\begin{Sinput}
 combo['active']
\end{Sinput}
\begin{Soutput}
[1] -1
\end{Soutput}
\end{Schunk}
%
The \method{getActiveText}{GtkComboBox} method retrieves
the text shown by the basic combo box.

When the active index changes, the \signal{changed} signal is
emitted. The handler then needs to retrieve the active index:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(combo, "changed",
                f = function(button, ...) {
                  if(button$getActive() < 0) 
                    message("No value selected")
                  else
                    message("Value is", button$getActiveText())
                })
\end{Sinput}
\end{Schunk}

Although combo boxes are much more space efficient than radio buttons,
it can still be difficult to use a combo box when there are a large
number of items. Placing the items in columns lessens this. The
\method{setWrapWidth}{GtkComboBox} method specifies the preferred
number of columns for displaying the items.

\begin{example}{Using one combo box to populate another}{ex:RGtk2-comboboxes}
%
The goal of this example is to populate a combo box of variables
whenever a data frame is selected in another. We use two convenience
functions from the \pkg{ProgGUIInR} package to find the possible data
frames, and for a data frame to find its variables.

We create the two combo boxes and the enclosing window:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE)
 window$setTitle("gtkComboBox example")
 df_combo <- gtkComboBoxNewText()
 var_combo <- gtkComboBoxNewText()
\end{Sinput}
\end{Schunk}
%

Our layout uses boxes. To add a twist, we will hide our variable combo box
until after a data frame has been initially selected.
\begin{Schunk}
\begin{Sinput}
 vbox <- gtkVBox(); window$add(vbox)
 #
 vbox1 <- gtkHBox(); vbox$packStart(vbox1)
 vbox1$packStart(gtkLabel("Data frames:"))
 vbox1$packStart(df_combo)
 #
 vbox2 <- gtkHBox(); vbox$packStart(vbox2)
 vbox2$packStart(gtkLabel("Variable:"))
 vbox2$packStart(var_combo)
 vbox2$hide()
\end{Sinput}
\end{Schunk}
%

Finally, we configure the combo boxes. When a data frame is selected, we
first clear out the variable combo box and then populate it:
\begin{Schunk}
\begin{Sinput}
 sapply(avail_dfs(), df_combo$appendText)
 df_combo$setActive(-1)
 #
 gSignalConnect(df_combo, "changed", function(df_combo, ...) {
   var_combo$getModel()$clear()
   sapply(find_vars(df_combo$getActiveText()),  
          var_combo$appendText)
   vbox2$show()
 })
\end{Sinput}
\end{Schunk}
%


\end{example}

An extension of \class{GtkComboBox}, \class{GtkComboBoxEntry},
replaces the main button with a text entry. This supports the entry of
arbitrary values, in addition to those present in the menu.



\subsection{Sliders and Spin buttons}
\label{sec:RGtk2:sliders-spinbuttons}

The slider widget and spin button widget allow selection from a
regularly spaced, semi-continuous list of values. Both have their
possible values for selection determined by an instance of
\class{GtkAdjustment}, which is used to represent ranges that have an
upper and lower bound with step and page increments. This adjustment
may be specified to the constructor, or more frequently will be
created by the widget after an appropriate specification of the range.

\paragraph{Sliders}
Sliders are implemented by \class{GtkScale} with constructors
\constructor{gtkHScale} and \constructor{gtkVScale}, the difference
being the orientation. 

These constructors have arguments \argument{min}{GtkScale},
\argument{max}{GtkScale} and \argument{step}{GtkScale} to specify
the range, if an adjustment is not specified. 

%% value
The \code{value} property stores the currently selected value. When
this is changed, the \signal{value-changed} signal is emitted. 

%% properties
A few properties define the appearance of the slider widget.  The
\code{digits} property controls the number of digits after the decimal
point.  The property \code{draw-value} toggles the drawing of the
selected value near the slider. Finally, \code{value-pos}
specifies where this value will be drawn using
values from \gtkenum{GtkPositionType}. The default is \code{top}.

In Example~\ref{eg-RGtk2-manipulate} we show how a slider can be used
to update a graphic.

\paragraph{Spin buttons}
The spin button widget is very similar to the slider widget,
conceptually and in terms of the \GTK\/ API. Spin buttons are
constructed with \constructor{gtkSpinButton}. As with sliders, this
constructor requires specifying adjustment values, either as a
\class{GtkAdjustment} or through the \argument{min}{gtkSpinButton},
\argument{max}{gtkSpinButton}, and \argument{step}{gtkSpinButton} arguments.
The argument \argument{digits}{gtkSpinButton} is used to configure how many
digits are displayed and \argument{climb.rate}{gtkSpinButton} can
adjust how fast the display changes when the button is held depressed.

As with \class{GtkScale} the \code{value} property holds the state and
the \signal{value-changed} signal is emitted when this changes.

A spin button has a few additional features. The property
\code{snap-to-ticks} can be set to \code{TRUE} to force the new value
to belong to the sequence of values in the adjustment. The \code{wrap}
property indicates whether the sequence will ``wrap'' around at the
bounds.

\begin{example}{A range widget}{ex:RGtk2-range-widget}
This example shows how to make a range widget that combines both the
slider and spinbutton to choose a single number
(Figure~\ref{fig:RGtk2-range-widget}). Such a widget is useful, as the
slider is better at large changes and the spin button better at finer
changes. In \GTK\/ we use the same \class{GtkAdjustment} model, so
changes to one widget propagate without effort to the other.

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{fig-RGtk2-range-widget.png}
  \caption{A range widget with coordinated slider and spin box sharing the same \class{GtkAdjustment} instance}
  \label{fig:RGtk2-range-widget}
\end{figure}


We name our scale parameters according to the corresponding arguments
to the \function{seq} function:
\begin{Schunk}
\begin{Sinput}
 from <- 0; to <- 100; by <- 1
\end{Sinput}
\end{Schunk}

The slider is drawn without a value, as the value is already displayed
by the spin button. The call to \constructor{gtkHScale} implicitly
creates an adjustment for the slider. The spin button is then created
with the same adjustment.
\begin{Schunk}
\begin{Sinput}
 slider <- gtkHScale(min = from, max = to, step = by)
 slider['draw-value'] <- FALSE
 adjustment <- slider$getAdjustment()
 spinbutton <- gtkSpinButton(adjustment = adjustment)
\end{Sinput}
\end{Schunk}
%
Our layout places the two widgets in a horizontal box container with
the slider, but not the spin button, set to expand into the available
space.
\begin{Schunk}
\begin{Sinput}
 hbox <- gtkHBox()
 hbox$packStart(slider, expand = TRUE, fill = TRUE, padding = 5)
 hbox$packStart(spinbutton, expand = FALSE, padding = 5)
\end{Sinput}
\end{Schunk}


\end{example}


%% JV Rewrote this to combine, removing example of histogram
% \subsection{Sliders}
% \label{sec:RGtk2:sliders}

% The slider widget and spin button widget allow selection from a
% regularly spaced, semi-continuous list of values.
% \class{GtkScale} implements a slider and may be oriented
% either horizontally or vertically. This depends on the class:
% \class{GtkHScale} or \class{GtkVScale}.  

% 
% \begin{example}{A slider controlling histogram bin selection}{ex:RGtk2:sliders}
%   We demonstrate a slider for controlling the bin size of a
%   histogram. In Example~\ref{eg-RGtk2-manipulate} we go much further
%   in this direction.
  
  
%   First, we create and configure the horizontal slider:
% <<gtk-widget-slider>>=
% slider <- gtkHScale(min = 1, max = 100, step = 1)
% slider$setValue(10)
% slider['value-pos'] <- "bottom"
% @ 
% %
% We specify the minimum, maximum and step values for the scale.  This
% set of values is formally represented by the \class{GtkAdjustment}
% structure, which could serve as a data model for synchronizing multiple
% sliders or other scale-based widgets. Ordinarily, it is not necessary
% to construct a \class{GtkAdjustment} explicitly. Instead, one passes
% the values as parameters to the constructor (which are named above, as
% the adjustment is the first argument). The initial value is set
% to $10$, and the value will be rendered in a label beneath the slider,
% according to the \property{value-pos}{GtkScale} property.

% The \signal{value-changed} signal is emitted whenever the slider is
% adjusted. Our handler updates the histogram:
% <<gtk-widget-slider-value-changed>>=
% gSignalConnect(slider, "value-changed",
%                f = function(w, ...) {
%                  val <- w$getValue() 
%                  drawHistogram(val)
%                })
% @ 

% Finally, we load the data, define the \function{drawHistogram}
% function, and finish the GUI:
% <<SliderAndHistogram, results=hide>>=
% data <- rnorm(100)

% library(lattice)
% drawHistogram <- function(val) print(histogram(data, nint = val))
% drawHistogram(slider$getValue())        

% w <- gtkWindow(); w$setTitle("Histogram bin selection")
% w$add(slider)
% @               
% \end{example}

% %% properties
% A few properties define the appearance of the slider widget.  The
% \code{digits} property controls the number of digits after the decimal
% point.  The property \code{draw-value} toggles the drawing of the
% selected value near the slider. Finally, \code{value-pos},
% demonstrated above, specifies where this value will be drawn using
% values from \code{GtkPositionType}. The default is \code{top}.

% \subsection{Spin buttons}
% \label{sec:RGtk2:spinboxes}

% The spin button widget is very similar to the slider widget,
% conceptually and in terms of the \GTK\/ API. Spin buttons are
% constructed with \constructor{gtkSpinButton}. As with sliders, this
% constructor requires specifying adjustment values, either as a
% \class{GtkAdjustment} or individually.  The methods
% \method{getValue}{gtkSpinButton} and \method{setValue}{gtkSpinButton}
% once again get and set the value. The \code{value-changed}
% signal is emitted when the spin button value is changed.

% \begin{example}{A range widget}{ex:RGtk2-range-widget}
%   \SweaveInput{ex-RGtk2-range-widget}
% \end{example}

% A spin button has a few additional features. The property
% \code{snap-to-ticks} can be set to \code{TRUE} to force the new value
% to belong to the sequence of values in the adjustment. The \code{wrap}
% property indicates whether the sequence will ``wrap'' around at the
% bounds


\section{Progress reporting}

\subsection{Progress bars}
\label{sec:progress-bars}

It is common to use a progress bar to indicate the progress of a long
running computation. This implemented by \class{GtkProgressBar}. A
text label describes the current operation, and the progress bar
communicates the fraction completed:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window$setTitle("Progress bar example")
 progressBar <- gtkProgressBar()
 window$add(progressBar)
 #
 progressBar$setText("Please be patient...")
 for(i in 1:100) {
   progressBar$setFraction(i/100)
   Sys.sleep(0.05) ## replace with a step in the process
 }
 progressBar$setText("All done.")
\end{Sinput}
\end{Schunk}

One can indicate indefinite activity by periodically pulsing the bar:
\begin{Schunk}
\begin{Sinput}
 progressBar$pulse()
\end{Sinput}
\end{Schunk}

\subsection{Spinners}

Related to a progress bar is the \class{GtkSpinner} widget, which is a
graphical heartbeat to assure the user that the application is still
alive during long-running operations. Spinners are commonly found in
web browsers. The basic usage is straightforward:
\begin{Schunk}
\begin{Sinput}
 spinner <- gtkSpinner()
 spinner$start()
 spinner$stop()
\end{Sinput}
\end{Schunk}


\section{Wizards}
\label{sec:gtk-wizards}

The \class{GtkAssistant} class provides a wizard widget for \GTK. The
simplest setup is that one adds pages to the assistant object and they
are navigated in a linear manner. In our example, we override this.

Wizard pages have a certain type which must be declared. These are
enumerated in \gtkenum{GtkAssistantPageType} and set by
\method{setPageType}{GtkAssistant}. The last page must be of type
\qcode{confirm}, \qcode{summary}, or \qcode{progress}.  Each wizard
page has a content area and buttons.  As well, each page in the
assistant object has an optional side image, header image and/or page
title that may be customized. The buttons allow the user to navigate
through the wizard. The content area of a wizard page is simply an
instance of class \class{GtkWidget} (e.g., some container) and are
added to the assistant through the \method{appendPage}{GtkAssistant},
\method{insertPage}{GtkAssistant}, or
\method{prependPage}{GtkAssistant} methods. Pages are referred to by
the \class{GtkWidget} object or their page index, $0$-based. The
\code{forward} button on a page must be made sensitive by calling
\method{setPageComplete}{GtkAssistant} with the widget and logical
value.

%% signal
\paragraph{Signals}
The \code{cancel} button emits a \signal{cancel} signal that can be
connected to for destroying the wizard widget. The \signal{apply}
signal is emitted on a page change. The \signal{prepare} signal is
emitted just before a page is made visible, which is needed to create
the dynamically generated pages in our example.

\begin{example}{An \code{install.packages} wizard}{eg-RGtk2-install-packages}

This example wraps the \function{install.packages} function into a
wizard with different pages for the (optional) selection of a CRAN
mirror, the selection of the package to install, the configuration
options provided and feedback. In general, wizards are quite common
for software installation.

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-RGtk2-install-wizard.png}
  \caption{An installation wizard programmed using
    \class{GtkAssistant}. This is page 4 which allows options for a
    call to \code{install.packages} to be configured.}
  \label{fig:RGtk2-install-wizard}
\end{figure}


We begin by defining our assistant and connecting to its
\signal{cancel} signal:
\begin{Schunk}
\begin{Sinput}
 assistant <- gtkAssistant(show=FALSE)
 assistant$setSizeRequest(500, 500)
 gSignalConnect(assistant, "cancel", 
                function(assistant) assistant$destroy())
\end{Sinput}
\end{Schunk}

Our pages will be computed dynamically. Here we populate the pages
using box containers and specify their respective types:
\begin{Schunk}
\begin{Sinput}
 pages <- lapply(1:5, gtkVBox, spacing = 5, homogeneous = FALSE)
 page_types <- c("intro", rep("confirm", 3), "summary")
 sapply(pages, gtkAssistantAppendPage, object = assistant)
 sapply(pages, gtkAssistantSetPageType, object = assistant, 
        type=page_types)
\end{Sinput}
\end{Schunk}
%
We customize each page with a side logo.
\begin{Schunk}
\begin{Sinput}
 image <- gdkPixbuf(filename = imagefile("rgtk-logo.gif"))[[1]]
 sapply(pages, gtkAssistantSetPageSideImage, object = assistant, 
        pixbuf = image)
\end{Sinput}
\end{Schunk}

When a page is about to be called, the \signal{prepare} signal is
emitted. In our handler, we check and see if it has any children. If
not, we call a function to lazily create the page. These functions are
stored in a list, so that they we can refer to them by index.
\begin{Schunk}
\begin{Sinput}
 populate_page <- list()                
 gSignalConnect(assistant, "prepare", 
        function(assistant, page, data) {
          page_no <- which(sapply(pages, identical, page))
          if(!length(page$getChildren()))
            populate_page[[page_no]]()
        })
\end{Sinput}
\end{Schunk}

Although we do not show how to create the CRAN selection page
(cf. Example~\ref{ex:RGtk2-add-toggle-to-df} for a similar
construction), we call \method{setForwardPageFunc}{GtkAssistant} to
set a function that will skip this page if it is not needed, i.e., if
the mirror has already been selected. The callback simply returns an
integer with the next page number based on the last one.
\begin{Schunk}
\begin{Sinput}
 assistant$setForwardPageFunc(function(page_index, data) {
   if(page_index == 0 && have_CRAN()) 
     2L 
   else 
     as.integer(page_index + 1)
 }, data=NULL)
\end{Sinput}
\end{Schunk}

We have a few script globals that allow us to pass data between pages:
\begin{Schunk}
\begin{Sinput}
 CRAN_package <- NA
 install_options <- list() #type, dependencies, lib
\end{Sinput}
\end{Schunk}






We now show how some of the pages are populated. The initial screen is
just a welcome and simply shows a label:
\begin{Schunk}
\begin{Sinput}
 populate_page[[1]] <- function() {
   assistant$setPageTitle(pages[[1]], "Install a CRAN package")
   pages[[1]]$packStart(label <- gtkLabel())
   pages[[1]]$packStart(gtkLabel(), expand=TRUE) # a spring
   
   label$setMarkup(paste(
        "<span font='x-large'>Install a CRAN package</span>",
        "This wizard will help install a package from",
        "<b>CRAN</b>. If you have not already specified a",
        "CRAN repository, you will be prompted to do so.",
        sep="\n"))
   assistant$setPageComplete(pages[[1]], TRUE)
 }
\end{Sinput}
\end{Schunk}


  
  

We skip showing the pages to select a CRAN site and a package, as they
are based on the forthcoming \class{GtkTreeView} class. On the fourth
page (cf.  Figure~\ref{fig:RGtk2-install-wizard} for a realization) is
a summary of the package taken from CRAN and a chance for the user to
configure a few options for the \function{install.packages} function.
\begin{Schunk}
\begin{Sinput}
 populate_page[[4]] <- function() {
   assistant$setPageTitle(pages[[4]], "Install a CRAN package")
   ##
   get_desc <- function(pkgname) {
     o <- "http://cran.r-project.org/web/packages/%s/DESCRIPTION"
     x <- readLines(sprintf(o, pkgname))
     f <- tempfile(); cat(paste(x, collapse="\n"), file=f)
     read.dcf(f)
   }
   desc <- get_desc(CRAN_package)
   #
   label <- gtkLabel()
   label$setLineWrap(TRUE)
   label$setWidthChars(40)
   label$setMarkup(paste(
     sprintf("Install package: <b>%s</b>", desc[1,'Package']),
     "\n",
     sprintf("%s", gsub("\\n", " ", desc[1,'Description'])),
     sep="\n"))
   
   pages[[4]]$packStart(label)
   ##
   table <- gtkTable()
   pages[[4]]$packStart(table, expand=FALSE)
   pages[[4]]$packStart(gtkLabel(), expand=TRUE)
   
   ##
   combo <- gtkComboBoxNewText()
   pkg_types <- c("source", "mac.binary", "mac.binary.leopard",
                  "win.binary", "win64.binary")
   sapply(pkg_types, combo$appendText)
   combo$setActive(which(getOption("pkgType") == pkg_types) - 1)
   gSignalConnect(combo, "changed", function(combo, ...) {
     cur <- 1L + combo$getActive()
     install_options[['type']] <<- pkg_types[cur]
   })
   table$attachDefaults(gtkLabel("Package type:"), 0, 1, 0, 1)
   table$attachDefaults(combo, 1, 2, 0, 1)
 
   ##
   checkButton <- gtkCheckButton()
   checkButton$setActive(TRUE)
   gSignalConnect(checkButton, "toggled", function(checkButton) {
     install_options[['dependencies']] <<- checkButton$getActive()
   })
   table$attachDefaults(gtkLabel("Install dependencies"),
                        0, 1, 1, 2)
   table$attachDefaults(checkButton, 1, 2, 1, 2)
 
   ##
   file_chooser <- gtkFileChooserButton("Select a directory...", 
                                       "select-folder")
   file_chooser$setFilename(.libPaths()[1])
   gSignalConnect(file_chooser, "selection-changed", 
                  function(file_chooser) {
                    dir <- file_chooser$getFilename()
                    install_options[['lib']] <<- dir
                  })
   table$attachDefaults(gtkLabel("Where"), 0, 1, 2, 3)
   table$attachDefaults(file_chooser, 1, 2, 2, 3)
   ## align labels to right and set spacing
   sapply(table$getChildren(), function(child) {
     widget <- child$getWidget()
     if(is(widget, "GtkLabel"))  widget['xalign'] <- 1
   })
   table$setColSpacing(0L, 5L)
   ##
   assistant$setPageComplete(pages[[4]], TRUE)
 }
\end{Sinput}
\end{Schunk}

Our last page, where the selected package is installed, would
naturally be of type \code{progress}, but there is no means to
interrupt the flow of \function{install.packages} to update the
page. A real application would reimplement that. Instead we just set a
message once the package install attempt is finished.
\begin{Schunk}
\begin{Sinput}
 populate_page[[5]] <- function() {
   assistant$setPageTitle(pages[[5]], "Done")
   install_options$pkgs <- CRAN_package
   out <- try(do.call("install.packages", install_options), 
              silent=TRUE)
 
   label <- gtkLabel(); pages[[5]]$packStart(label)
   if(!inherits(out, "try-error")) {
     label$setMarkup(sprintf("Package %s installed successfully", 
                             CRAN_package))
   } else {
     label$setMarkup(paste(sprintf("Package %s failed to install", 
                                   CRAN_package),
                           paste(out, collapse="\n"),
                           sep="\n"))
   }
 
   assistant$setPageComplete(pages[[5]], FALSE)
 }
\end{Sinput}
\end{Schunk}

To conclude, we populate the first page and call the assistant's
\meth{show} method:
\begin{Schunk}
\begin{Sinput}
 populate_page[[1]]()
 assistant$show()
\end{Sinput}
\end{Schunk}
\end{example}

\section{Embedding R graphics}
\label{sec:gtk-widget-graphics}

%% using cairoDevice to embed graphics
%% cairoDevice

The package \pkg{cairoDevice} is an R graphics device based on the
Cairo graphics library.  It supports alpha-blending and antialiasing
and reports user events through the \function{getGraphicsEvent}
function. \pkg{RGtk2} and \pkg{cairoDevice} are integrated through the
\function{asCairoDevice} function. If a \class{GtkDrawingArea},
\class{GdkDrawable}, \class{Cairo} context, or \class{GtkPrintContext}
is passed to \function{asCairoDevice}, an R graphics device will be
initialized that targets its drawing to the object. For simply
displaying graphics in a GUI, the \class{GtkDrawingArea} is the best
choice. 

This is the simplest usage:
\begin{Schunk}
\begin{Sinput}
 library(cairoDevice)
 device <- gtkDrawingArea()
 asCairoDevice(device)
 ##
 window <- gtkWindow(show=FALSE)
 window$add(device)
 window$showAll()
 plot(mpg ~ hp, data = mtcars)
\end{Sinput}
\end{Schunk}
%
In the above, we create the \class{GtkDrawingArea}, coerce it to a
Cairo-based graphics device, and then place it in a
window. Example~\ref{sec:RGtk2:scroll-windows} goes further by
embedding the drawing area into a scrolled window to support zooming
and panning.

For more complex use cases, such as compositing a layer above or below
the R graphic, one should pass an off-screen \class{GdkDrawable}, like
a \class{GdkPixmap}, or a \class{Cairo} context. The off-screen
drawing could then be composited with other images when
displayed. Example~\ref{ex:RGtk2:pixbuf} generates an icon by pointing
the device to a pixmap. Finally, passing a \class{GtkPrintContext} to
\function{asCairoDevice} allows printing R graphics through the \GTK\/
printing dialogs.

\begin{example}{Printing R graphics}{eg:RGtk2:printing-graphics}
  This example will show how to use the printing support in \GTK\/ for
  printing an R plot. 
  
  A print operation is encapsulated by \class{GtkPrintOperation}:
\begin{Schunk}
\begin{Sinput}
 print_op <- gtkPrintOperation()
\end{Sinput}
\end{Schunk}
%
A print operation may perform several different actions: print
directly, print through a dialog, show a print preview and export to a
file. Before performing any such action, we need to implement the
rendering of our document into printed form. This is accomplished by
connecting to the \signal{draw-page} signal. The handler is passed a
\class{GtkPrintContext}, which contains the target Cairo context. In
general, one would call Cairo functions to render the document, which
is beyond our scope. In this case, though, we can pass the context
directly to \pkg{cairoDevice} for rendering the R plot:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(print_op, "draw-page", 
                function(print_op, context, page_nr) {
                  asCairoDevice(context)
                  plot(mpg ~ wt, data = mtcars)
                })
\end{Sinput}
\end{Schunk}
%
  The final step is to run the operation to perform one of the
  available actions. In this example, we launch a print dialog:
\begin{Schunk}
\begin{Sinput}
 print_op$run(action = "print-dialog", parent = NULL)
\end{Sinput}
\end{Schunk}
% 
  When the user confirms the dialog, the
  \signal{draw-page} handler is invoked, and the
  rendered page is sent to the printer.
\end{example}

%% JV: Added a new example combining some basic widgets, the cairo
%% device and a reference class
\begin{example}{The \pkg{manipulate} package in \pkg{RGtk2}}{eg-RGtk2-manipulate}

RStudio\texttrademark{} is an IDE for R that provides a
similar interface whether run on any of its supported operating
systems or through a web browser. Accompanying the IDE is an
\R{} package \pkg{manipulate} that provides a convenient means to
create simple graphical interfaces for plotting. As RStudio leverages
web technologies to render its widgets and there is no public
interface, the package is not available for non-RStudio users. Too
bad. This example shows how one can use \pkg{RGtk2} to provide a
similar interface. In the example, we borrow liberally from the
\pkg{manipulate} code, which is released under an AGPL
license. Although we don't show the entire code here, the
\pkg{ProgGUIinR} package contains it all.

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{fig-RGtk2-manipulate.png}
  \caption{An implementation of RStudio's \pkg{manipulate} package in \pkg{RGtk2}}
  \label{fig:RGtk2-manipulate}
\end{figure}



The \pkg{manipulate} package uses environments to store state
etc. Here we use reference classes, as they allow for a more
structured programming interface. 

A typical use of \pkg{manipulate} is along the lines of
(Figure~\ref{fig:RGtk2-manipulate}) the following example from the
\pkg{manipulate} help pages:
\begin{Schunk}
\begin{Sinput}
 manipulate(## expression
            plot(cars, xlim = c(x.min, x.max), type = type, 
                 axes = axes, ann = label),
            ## controls
            x.min = slider(0, 15),
            x.max = slider(15, 30, initial = 25),
            type = picker("p", "l", "b", "c", "o", "h", "s"),
            axes = checkbox(TRUE, label = "Draw Axes"),
            label = checkbox(FALSE, label = "Draw Labels")
            )
\end{Sinput}
\end{Schunk}
%
The first argument is an expression, possibly containing parameters,
that produces a plot. The other arguments create widgets that
control the parameter values in the plotting expression. There are
three basic controls: a slider, a picker (combo box), and a check
box. As one can glean, the constructors have a terse but simple set
of arguments. A main task ahead will be mapping these controls to one
of \GTK's widgets.

For now, we begin by defining our \code{Manipulate} class to have two
properties, one to hold the expression and the other to hold a list of controls.
\begin{Schunk}
\begin{Sinput}
 Manipulate <- setRefClass("Manipulate",
                           fields=list(
                             .code="ANY",
                             .controls="list"
                             ))
\end{Sinput}
\end{Schunk}
%



When one of the controls is changed, the entire plot will be
redrawn. The following handler will be assigned to each control. Its
environment contains the main properties so the evaluation can be done
as expected. Note that each control is expected to provide a
\meth{get\_value} method.

\begin{Schunk}
\begin{Sinput}
 Manipulate$methods(
            get_values = function() {
              "Get widget values as list"
              sapply(.controls, 
                     function(control) control$get_value(), 
                     simplify=FALSE)
            },
            change_handler = function(...) {
              "Evaluate code with current values"
              values <- get_values()
              result <- withVisible(eval(.code, envir = values))
              if (result$visible) {
                eval(print(result$value))
              }
            })
\end{Sinput}
\end{Schunk}
%

The \meth{execute} method is called after initialization to setup the
GUI. We use a \class{GtkHPaned} instance to allow the user to adjust
the space between the graphic device and the controls frame. Each
control is expected to provide a \meth{make\_gui} interface.

\begin{Schunk}
\begin{Sinput}
 Manipulate$methods(  
            execute=function() {
              "Make the GUI"
              window <- gtkWindow(show=FALSE)
              window$setTitle("ManipulateR")
              ## Set up graphic device
              hpaned <- gtkHPaned()
              window$add(hpaned)
              device <- gtkDrawingArea()
              device$setSizeRequest(480, 480)
              asCairoDevice(device)
              hpaned$add(device)
              ## Controls frame
              frame <- gtkFrame("Controls")
              control_table <- gtkTableNew()
              control_table$setHomogeneous(FALSE)
              control_table['column-spacing'] <- 10
              ## insert horizontal strut
              control_table$attach(strut <- gtkHBox(), 1,2,0,1,
                            xoptions="", yoptions="shrink")
              strut$setSizeRequest(75, -1)
              frame$add(control_table)
              hpaned$add(frame)
              ## add each control
              sapply(.controls, function(control) {
                control$make_gui(cont=control_table, 
                                 handler=.self$change_handler)
              })
              window$show()
              change_handler()                    # initial
            })
\end{Sinput}
\end{Schunk}
%

The \code{control\_table} is used hold the respective controls. We
added a \ilayout{struts}strut to request a minimum width for the
second column, as otherwise the slider controls can render too
narrowly.



The initialize method calls a function provided by the
\pkg{manipulate} package to to pick the controls out of the \code{...}
argument. The \code{validate\_controls} method is not shown, but
simply borrows code from the package to do some error checking,
ensuring the controls are defined properly.

\begin{Schunk}
\begin{Sinput}
 Manipulate$methods(  
            initialize = function(code, ...) {
              controls <- resolveVariableArguments(list(...))
              initFields(.code = code,
                         .controls = controls)
              validate_controls()
              callSuper()
            })
\end{Sinput}
\end{Schunk}
%

We now provide a constructor allowing access to our class.
\begin{Schunk}
\begin{Sinput}
 manipulate <- function(`_expr`,...) {
   manip <- Manipulate$new(substitute(`_expr`),...)
   manip$execute()
 }
\end{Sinput}
\end{Schunk}
%

There are three main controls, but perhaps more could be added. We
give ourselves the flexibility to expand by creating a base class for
a control that can be subclassed. We define the class below. The
properties are \code{l}, to store a list of arguments (a legacy of the
original code); \code{widget}, to store the widget; \code{label} to
hold the label for the control; and \code{initial}.


\begin{Schunk}
\begin{Sinput}
 ManipulateControls <- setRefClass("ManipulateControls",
                         fields=list(
                           l="list",
                           widget = "ANY",
                           label="character",
                           initial="ANY"
                           ))
\end{Sinput}
\end{Schunk}

There main interface includes three methods: \meth{validate\_inputs}
(to ensure the control is defined properly) and the previously noted
\meth{get\_value} and \meth{make\_gui} (defined separately).
\begin{Schunk}
\begin{Sinput}
 ManipulateControls$methods(
             validate_inputs = function(...) {
               "Validate input code"
             },
             get_value = function(...) {
               "Get value of widget"
             })
\end{Sinput}
\end{Schunk}

The \meth{make\_gui} method has two tasks: to define the widget
instance and to add the widget to the GUI. This is done in the base
class. The label and widget are added as a row to a \class{GtkTable} instance.
\begin{Schunk}
\begin{Sinput}
 ManipulateControls$methods(make_gui = function(cont) {
             "Create widget, then add to table"
             ## cont a GtkTable instance
             nrows <- cont['n-rows']
             label_widget <- gtkLabel(label)
             label_widget['xalign'] <- 1
             cont$attach(label_widget, 0, 1, nrows, nrows + 1,
                         xoptions = "shrink", yoptions = "shrink"
                         )
             cont$attach(widget, 1, 2, nrows, nrows + 1,
                         xoptions = c("expand", "fill"),
                         yoptions = "")
           })
\end{Sinput}
\end{Schunk}

The \code{slider} constructor just creates an instance of a soon to be
defined sub-class of the \class{ManipulateControls} class. The
arguments follow RStudio's.

\begin{Schunk}
\begin{Sinput}
 slider <- function(min, max, initial = min, label = NULL, 
                    step = -1, ticks = TRUE) {
   Slider$new(min, max, initial = initial, label = label, 
              step = step, ticks = ticks)
 }
\end{Sinput}
\end{Schunk}

The \class{Slider} class has no new properties:
\begin{Schunk}
\begin{Sinput}
 Slider <- setRefClass("Slider",
                       contains = "ManipulateControls")
\end{Sinput}
\end{Schunk}




The \meth{initialize} method simply creates a list and sets some
properties. This follows the setup of the original package.
\begin{Schunk}
\begin{Sinput}
 Slider$methods(
        initialize = function(min, max, initial = min, 
          label = NULL, step = -1, ticks = TRUE, ...) {
            validate_inputs(min, max, initial, step, ticks)
            ## create slider and return it
            slider <- list(type = 0,
                           min = min,
                           max = max,
                           step = step,
                           ticks = ticks)
            initFields(l = slider, label = label, 
                       initial = initial)
            .self
          })
\end{Sinput}
\end{Schunk}

Our \meth{make\_gui} method basically defines the widget, turning the
arguments of the constructor into those for the \GTK{} widget. It then
calls the same method from the superclass to lay it the widget. Here
we define a slider and initialize it using the values in the list,
\code{l}. The \code{handler} is the change handler passed in from a
\class{Manipulate} instance.
\begin{Schunk}
\begin{Sinput}
 Slider$methods(
        make_gui = function(cont, handler, ...) {
          widget <<- gtkHScale(min = l$min, max = l$max, 
                               step = l$step)
          widget$setValue(initial)
          gSignalConnect(widget, "value-changed", handler)
          callSuper(cont)
        },
        get_value = function() {
          as.numeric(widget$getValue())
        })
\end{Sinput}
\end{Schunk}


%

%% Not showing the combobox one. Could, but isn't anything special
The \function{picker} and \function{checkbox} functions (and their
classes) are similarly defined. For example, the \class{Checkbox}
class, the three main methods are given by:
\begin{Schunk}
\begin{Sinput}
 Checkbox$methods(
          initialize = function(initial = FALSE, label = NULL) {
            validate_inputs(initial, label)
            checkbox <- list(type = 2)
            initFields(l = checkbox, label = label, 
                       initial = initial)
            .self
          },
          make_gui = function(cont, handler, ...) {
            widget <<- gtkCheckButton() # no label
            widget$setActive(initial)
            gSignalConnect(widget, "toggled", handler)
            callSuper(cont)
          },
          get_value = function() widget['active']
          )
\end{Sinput}
\end{Schunk}
%
We don't provide a label to the check button, as one is provided in
the table.


%% Try it out
\end{example}

\igui{drag and drop}
\section{Drag and drop}
\label{sec:RGtk2:dnd}

%% ------------ Drag and Drop

A drag and drop operation is the movement of data from a source widget
to a target widget. In \GTK{} the source widget serializes the
selected item as MIME data, and the destination interprets that data
to perform some operation, often creating an item of its own. Our task
is to configure the source and destination widgets, so that they
listen for the appropriate events and understand each other. As a
trivial example, we allow the user to drag the text from one button to
another.

\subsection{Initiating a drag}

When a drag and drop is initiated, different types of data may be
transferred. We need to define a target type for each type of data, as
a \class{GtkTargetEntry} structure:
\begin{Schunk}
\begin{Sinput}
 TARGET.TYPE.TEXT   <- 80                # our enumeration
 TARGET.TYPE.PIXMAP <- 81                  
 widgetTargetTypes <- 
   list(text = gtkTargetEntry("text/plain", 0, 
          TARGET.TYPE.TEXT),
        pixmap = gtkTargetEntry("image/x-pixmap", 0, 
          TARGET.TYPE.PIXMAP))
\end{Sinput}
\end{Schunk}
%
The first component of \class{GtkTargetEntry} is the name, which is often
a MIME type. The flags come next, which are usually left at $0$, and
finally we specify an arbitrary identifier for the target. We will
only use the \qcode{text} target in this example.

We construct a button and call \function{gtkDragSourceSet} to instruct
it to act as a drag source:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window['title'] <- "Drag Source"
 dragSourceWidget <-  gtkButton("Text to drag")
 window$add(dragSourceWidget)
 gtkDragSourceSet(dragSourceWidget,
        start.button.mask=c("button1-mask", "button3-mask"),
        targets=widgetTargetTypes[["text"]],
        actions="copy")
\end{Sinput}
\end{Schunk}
%
The \argument{start.button.mask}{gtkDragSourceSet}, with values from
\class{GdkModifierType}, indicates the modifier buttons that need to
be pressed to initiate the drag. The allowed target is \qcode{text} in
this case. The \argument{actions}{gtkDragSourceSet} argument lists the
supported actions, such as \code{copy} or \code{move}, from the
\gtkenum{GdkDragAction} enumeration.

When a drag is initiated, we will receive the \signal{drag-data-get}
signal, which needs to place some data into the passed
\class{GtkSelectionData} object:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(dragSourceWidget, "drag-data-get", 
                function(widget, context, sel, tType, eTime) {
                  sel$setText(widget$getLabel()) 
                })
\end{Sinput}
\end{Schunk}
%
If we had allowed the \code{move} action, we would also need to
connect to \signal{drag-data-delete}, in order to delete the data that
was moved away.

\subsection{Handling drops}

In a separate window from the drag source button, we construct another
button and call \function{gtkDragDestSet} to mark it as a drag target:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(); window['title'] <- "Drop Target"
 dropTargetWidget <- gtkButton("Drop here")
 window$add(dropTargetWidget)
 gtkDragDestSet(dropTargetWidget,
                flags="all", 
                targets=widgetTargetTypes[["text"]],
                actions="copy")
\end{Sinput}
\end{Schunk}
%
The signature is similar to that of \function{gtkDragSourceSet},
except for the \argument{flags}{gtkDragDestSet} argument, which
indicates which operations, of the set \code{motion}, \code{highlight}
and \code{drop}, \GTK\/ will handle with reasonable default
behavior. Specifying \code{all} is the most convenient course, in
which case we only need to implement the extraction of the data from
the \class{GtkSelectionData} object. For a drop to occur, there must be a
non-empty intersection between the targets passed to
\function{gtkDragSourceSet} and those passed to
\function{gtkDragDestSet}.

When data is dropped, the destination widget emits the
\signal{drag-data-received} signal. The handler is responsible for
extracting the dragged data from \args{selection} and performing some
operation with it. In this case, we set the text on the button:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(dropTargetWidget, "drag-data-received", 
        function(widget, context, x, y, sel, tType, eTime) {
          dropdata <- sel$getText()
          widget$setLabel(rawToChar(dropdata))
        })
\end{Sinput}
\end{Schunk}
%
The \args{context} argument is a \class{GdkDragContext},
containing information about the drag event. The \args{x} and
\args{y} arguments are integer valued and represent the position
in the widget where the drop occurred. The text data is returned by
\function{getText} as a \code{raw} vector, so it is converted with
\function{rawToChar}.

%% JV: This could be expanded -- motion is not covered, as is done with
%% tcltk, but I don't think it is needed without a compelling use case.

%% ML: agreed

\chapter{RGtk2: Widgets Using Data Models}
\label{sec:RGtk2:widgets-with-models}

%% Possible outline:
%% - Displaying tabular data (GtkTreeView)
%%   - Loading data frame
%%   - Displaying data frame
%%   - Accessing GtkTreeModel (to set up selection, and hierarchical data)
%%   - Selection (an important concept, but common to hierarchical, below)
%%   - Sorting/filtering
%%   - Cell renderer details
%% - Displaying hierarchical data (GtkTreeView)
%%   - Loading hierarchical data
%%   - Displaying data as a tree
%% - Model-based combo boxes
%% - Text entry completion
%% - Icon views (currently omitted, probably OK)
%% - Text views

%% TODO: we need a unified example in the main text that spans loading
%% a data frame to sorting a model, at least.

Many widgets in \GTK\/ use the model-view-controller \iprogram{model-view-controller}(MVC)
paradigm. For most, like the button, the MVC pattern is implicit;
however, widgets that primarily display data explicitly incorporate
the MVC pattern into their design. The data model is factored out as a
separate object, while the widget plays the role of the view and
controller. The MVC approach adds a layer of complexity but
facilitates the display of the dynamic data in multiple, coordinated
views.

\section{Display of tabular data}
\label{sec:RGtk2:tabular-heirarchical-data}

Widgets that display lists, tables and trees are all based on the same
basic data model, \class{GtkTreeModel}. Although its name suggests a
hierarchical structure, \class{GtkTreeModel} is also tabular. We first
describe the display of an \R\/ data frame in a list or table
view. The display of hierarchical data, as well as further details of
the \class{GtkTreeModel} framework, are treated subsequently.

\igui{data frame model}
\subsection{Loading a data frame}
\label{sec:tabular-stores-tree}

As an interface, \class{GtkTreeModel} may be implemented in any number
of ways. \GTK\/ provides simple in-memory implementations for
hierarchical and non-hierarchical data.  \R\/ uses data frames to hold
tabular data, where each column is of a certain class, and each row is
related to some observational unit. This fits the structure of
\class{GtkTreeModel} when there is no hierarchy.  The
\class{RGtkDataFrame} class implements \class{GtkTreeModel} on top of
an \R\/ data frame. Compared to the model implementations built into
\GTK, \Rclass{RGtkDataFrame} affords the \R\/ programmer the benefits
of improved speed, convenience and familiarity.

For non-hierarchical data, this is
usually the model of choice, so we discuss it first. Populating a
\class{RGtkDataFrame} is far faster than for a \GTK\/ model, because
data is retrieved from the data frame on demand. There is no need to
copy the data row by row into a separate data structure. Such an
approach would be especially slow if implemented as a loop in
\R.~\footnote{As is proved with \pkg{tcltk}, where this is needed.} The constructor
\constructor{rGtkDataFrame} takes a
data frame as an argument. The column classes are important, so even
if this data frame is empty, the user should specify the desired
column classes upon construction.

An object of class \class{RGtkDataFrame} supports the familiar S3
methods \method{[}{RGtkDataFrame}, \method{[\ASSIGN}{RGtkDataFrame},
\method{dim}{RGtkDataFrame}, and
\method{as.data.frame}{RGtkDataFrame}. The \code{[$<$-} method does
not have quite the same functionality as it does for a data
frame. Columns can not be removed by assigning values to \code{NULL},
and column types should not be changed. These limitations are inherent
in the design of \GTK: columns may not be removed from
\class{GtkTreeModel}, and views expect the data type to remain the
same.

\begin{example}{Defining and manipulating a \class{RGtkDataFrame}}{eg-RGtk2-manipulate-rGtkDataframe}
  The basic data frame methods are similar.
\begin{Schunk}
\begin{Sinput}
 data(Cars93, package="MASS")             # mix of classes
 model <- rGtkDataFrame(Cars93)
 model[1, 4] <- 12
 model[1, 4]                              # get value
\end{Sinput}
\begin{Soutput}
[1] 12
\end{Soutput}
\end{Schunk}
%
As with a data frame, assignment to a factor must be from one of the
possible levels.

\end{example}

The data frame combination functions \function{rbind} and
\function{cbind} are unsupported, as they would create a new data
model, rather than modify the model in place. Thus, one should add
rows with \method{appendRows}{RGtkDataFrame} and add columns with
\method{appendColumns}{RGtkDataFrame} (or sub-assignment, 
\method{[\ASSIGN}{RGtkDataFrame}).

The \method{setFrame}{RGtkDataFrame} method replaces the underlying
data frame.
\begin{Schunk}
\begin{Sinput}
 model$setFrame(Cars93[1:5, 1:5])
\end{Sinput}
\end{Schunk}
%
Replacing the data frame is the only way to remove rows, as this is
not possible with the conventional data frame sub-assignment
interface. Removing columns or changing their types remains
impossible. The new data frame cannot contain more columns and rows
than the current one. If the new data frame has more rows or columns,
then the appropriate \code{append} method should be used first.

\subsection{Displaying data as a list or table}
\label{sec:RGtk2:mvc:GtkTreeView}

%% intro
\class{GtkTreeView} is the primary view of \class{GtkTreeModel}.  It
serves as the list, table and tree widget in \GTK. A tree view is
essentially a container of columns, where every column has the same
number of rows. If the view has a single column, it is essentially a
list. If there are multiple columns, it is a table. If the rows are
nested, it is a tree table, where every node has values on the same
columns.

%% constructor
A tree view is constructed by \constructor{gtkTreeView}:
\begin{Schunk}
\begin{Sinput}
 view <- gtkTreeView(model)
\end{Sinput}
\end{Schunk}
Usually, as in the above, the model is passed to the
constructor. Otherwise, the model may be accessed with
\method{setModel}{GtkTreeView} and \method{getModel}{GtkTreeView}.

A newly created tree view displays zero columns, regardless of the
number of columns in the model. Each column, an instance of
\class{GtkTreeViewColumn}, must be constructed, inserted into the view and
instructed to render content based on one or more columns in the data
model:
\begin{Schunk}
\begin{Sinput}
 column <- gtkTreeViewColumn()
 column$setTitle("Manufacturer")
 cell_renderer <- gtkCellRendererText()
 column$packStart(cell_renderer)
 column$addAttribute(cell_renderer, "text", 0)
 view$insertColumn(column, 0)
\end{Sinput}
\end{Schunk}
%
A column with the title ``Manufacturer'' is inserted at the first,
$0$-based, position. For displaying a simple data frame, we only need
to render text. Each row in a column consists of one or more cells,
managed in a layout. The number of cells and how each cell is rendered
is uniform down a column. As an implementation of
\class{GtkCellLayout}, \class{GtkTreeViewColumn} delegates the
responsibility of rendering to one or more \class{GtkCellRenderer}
objects. The cell renderers are packed into the column, which behaves
much like a box container. Rendering of text cells is the role of the
\class{GtkCellRendererText} class. There are several properties that
control how the text is rendered. A so-called \textit{attribute} links
a model column to a renderer property. The most important property is
\code{text}, the text itself. In the example, we bind the \code{text}
property to the first ($0$-indexed) column in the model.

\class{GtkTreeView} provides the
\method{insertColumnWithAttributes}{GtkTreeView} convenience method to
perform all of these steps with a single call. We invoke it to add a
second column in our view:
\begin{Schunk}
\begin{Sinput}
 view$insertColumnWithAttributes(position = -1, 
                                 title = "Model", 
                                 cell = gtkCellRendererText(), 
                                 text = 2 - 1) # second column
\end{Sinput}
\end{Schunk}
% 
The $-1$ passed as the first argument indicates that the column should
be appended. Next, we specify the column title, a cell renderer, and
an attribute that links the \code{text} renderer property to the
second column in the model. In general, any number of attributes may
be defined after the third argument.  We will use the above idiom in
all of the following examples, as it is much more concise than
performing each step separately.

Displaying the entire Cars93 data frame is not much different. Here,
we reconstruct the view, inserting a view column for every column in
the data frame, i.e., the model.
\begin{Schunk}
\begin{Sinput}
 view <- gtkTreeView(model)
 mapply(view$insertColumnWithAttributes,  
        position = -1, 
        title = colnames(model), 
        cell = list(gtkCellRendererText()), 
        text = seq_len(ncol(model)) - 1
        )
\end{Sinput}
\end{Schunk}

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-RGtk2-scrollable-treeview}
  \caption{A \class{GtkTreeView} instance shown with a scrolled window}
  \label{fig:RGtk2-scrollable-treeview}
\end{figure}

Figure~\ref{fig:RGtk2-scrollable-treeview} shows the view within a scrollable window:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow()
 window$setTitle("Tabular view of data frame")
 scrolled_window <- gtkScrolledWindow()
 window$add(scrolled_window)
 scrolled_window$add(view)
\end{Sinput}
\end{Schunk}
%
%% JV cut this out
% Although it was relatively easy to create a \class{GtkTreeModel} for
% the data frame using \class{RGtkDataFrame}, the complexity of
% \class{GtkTreeView} complicates the task of displaying the data frame
% in a simple, textual table. When this is all that is necessary, one
% might consider \function{gtable} from \pkg{gWidgets}. For those
% who wish to render text in each row differently (e.g., in a different
% color) or fill cells with images, check boxes, progress bars and the
% like, direct use of the \class{GtkTreeView} API is required.

\paragraph{Manipulating view columns}
The \class{GtkTreeView} widget is essentially a collection of
columns. Columns are added to the tree view with the methods
\method{insertColumn}{GtkTreeView} or, as shown above,
\method{insertColumnWithAttributes}{GtkTreeView}.  A column can be
moved with the \method{moveColumnAfter}{GtkTreeView} method, and
removed with the \method{removeColumn}{GtkTreeView} method. The
\method{getColumns}{GtkTreeView} method returns a list containing all
of the tree view columns.

There are several properties for controlling the behavior and
dimensions of a \class{GtkTreeViewColumn} instance. The property
\qcode{resizable} determines whether the user can resize a column, by
dragging with the mouse. The size properties \qcode{width},
\qcode{min-width}, and \qcode{fixed-width} control the size. The
visibility of the column can be adjusted through the
\method{setVisible}{GtkTreeViewColumn} method.

\paragraph{Additional features}
Tree views have several special features, including sorting,
incremental search and drag-n-drop reordering. Sorting is discussed in
Section~\ref{sec:RGtk2:mvc:proxies}. To turn on searching,
\code{enable-search} should be \code{TRUE} (the default) and the
\code{search-column} property should be set to the column to be
searched. The tree view will popup a search box when the user types
\kbd{control-f}. To designate an arbitrary text entry widget as the
search box, call \method{setSearchEntry}{GtkTreeView}. The entry can
be placed anywhere in the GUI. Columns are always reorderable by drag
and drop. Reordering rows through drag-and-drop is enabled by the
\code{reorderable} property.

\paragraph{Aesthetic properties}

\class{GtkTreeView} is capable of rendering some visual guides. The
\code{rules-hint}, if \code{TRUE}, will instruct the theme to draw
rows in alternating colors. To show grid lines, set
\code{enable-grid-lines} to \code{TRUE}.

\subsection{Accessing \class{GtkTreeModel}}
\label{sec:RGtk2:mvc:iterators}

Although \class{RGtkDataFrame} provides a familiar interface for
manipulating the data in a \class{GtkTreeModel}, it is often necessary
to directly interact with the \GTK\/ API, such as when using another
type of data model or interpreting user selections. There are two
primary ways to index into the rows of a tree model: paths and
iterators.

To index directly into an arbitrary row, a \class{GtkTreePath} is
appropriate. For a table, a tree path is essentially the row number,
$0$-based; for a tree it is a sequence of integers referring to the
offspring index at each level. The sequence of integers may be
expressed as either a numeric vector or a string, using
\constructor{gtkTreePathNewFromIndices} or
\constructor{gtkTreePathNewFromString}, respectively. For a flat table
model, there is only one integer in the sequence:
\begin{Schunk}
\begin{Sinput}
 second_row <- gtkTreePathNewFromIndices(2)
\end{Sinput}
\end{Schunk}
%
Referring to a row in a hierarchy is slightly more complex:
\begin{Schunk}
\begin{Sinput}
 abc_path <- gtkTreePathNewFromIndices(c(1, 3, 2))
 abc_path <- gtkTreePathNewFromString("1:3:2")
\end{Sinput}
\end{Schunk}
%
In the above, both paths refer to the second child of the third child
of the first top-level node. To recover the integer or string
representation of the path, use \method{getIndices}{GtkTreePath} or
\method{toString}{GtkTreePath}, respectively.

%% iters
\paragraph{Iterators}
\iprogram{iterators} The second means of row indexing is through an
iterator, \class{GtkTreeIter}, which is better suited for traversing a
model.  An \dfn{iterator} is a programming object\iprogram{iterator
  pattern} used to traverse through some data, such as a text buffer
or table of values. Iterators are typically transient, in the sense
that they are invalidated when their source is modified. An iterator
is often updated by reference\iprogram{references}, behavior that is
atypical in \R\/ programming.


While a tree path is an intuitive, transparent row index, an iterator
is an opaque index that is efficiently incremented. It is
probably most common for a model to be accessed in an iterative
manner, so all of the data accessor methods for \class{GtkTreeModel}
expect \class{GtkTreeIter}, not \class{GtkTreePath}. The \GTK\/
designers imagined that the typical user would obtain an iterator for
the first row and visit each row in sequence:
\begin{Schunk}
\begin{Sinput}
 iter <- model$getIterFirst()
 manufacturer <- character()
 while(iter$retval) {
   manufacturer <- c(manufacturer, model$get(iter$iter, 0)[[1]])
   iter$retval <- model$iterNext(iter$iter)
 }
\end{Sinput}
\end{Schunk}
%
In the above, we recover the manufacturer column from the Cars93 data
frame. Whenever a \class{GtkTreeIter} is returned by a
\class{GtkTreeModel}, the return value in \R\/ is a list of two
components: \code{retval}, a logical indicating whether the iterator
is valid, and \code{iter}, the pointer to the underlying C data
structure. The call to \method{get}{GtkTreeModel} also returns a list,
with an element for each column index passed as an argument. The
method \method{iterNext}{GtkTreeStore} updates the passed iterator in
place, i.e., by reference, to point to the next row. Thus, no new
iterator is returned. This is unfamiliar behavior in \R. Instead, the
method returns a logical value indicating whether the iterator is
still valid, i.e. \code{FALSE} is returned if no next row exists.

It is clear that the above usage is designed for languages like C,
where multiple return values are conveniently passed by reference
parameters. This iterator design also prevents the use of the apply
functions (\R's iterators), which are generally preferred over the \code{while} loop
for reasons of performance and clarity. An improvement would be to
obtain the number of children, generate the sequence of row indices
and access the row for each index:
\begin{Schunk}
\begin{Sinput}
 nrows <- model$iterNChildren(NULL)
 manufacturer <- sapply(seq(nrows) - 1L, function(i) {
   iter <- model$iterNthChild(NULL, i)
   model$get(iter$iter, 0)[[1]]
 })
\end{Sinput}
\end{Schunk}
%
Here we use \code{NULL} to refer to the virtual root node that sits
above the rows in our table. Unfortunately, this usage too is
unintuitive and slow, so the benefits of \class{RGtkDataFrame} should
be obvious.

\paragraph{Converting between paths and iterators}
One can convert between paths and iterators. The method
\method{getIter}{GtkTreeModel} on \class{GtkTreeModel} returns an
iterator for a path. A shortcut from the string representation of the
path to an iterator is \method{getIterFromString}{GtkTreeModel}. The
path pointed to by an iterator is returned by
\method{getPath}{GtkTreeModel}.

One final point: \class{GtkTreeIter} is created and managed by the
model, while \class{GtkTreePath} is model independent. It is not
possible to use iterators across models or even across modifications
to a model. After a model changes, an iterator is invalid. A tree path
may still point to a valid row, though it will not in general be the
same row from before the change. To refer to the same row across tree
model changes, use a \class{GtkTreeRowReference}.

\subsection{Selection}
%% selection: none, single browse multiple, getSelected

There are multiple modes of user interaction with a tree view: if the
cells are not editable, then selection is the primary mode.  A single
click selects the value, and a double click is often used to initiate
an action. If the cells are editable, then a double click or a click
on an already selected row will initiate editing of the
content. Editing of cell values is a complex topic and is handled by
derivatives of \class{GtkCellRenderer}, see
%% FIXME: these references are just going to the top of this
%% section. Apparently, the subsections are not available for reference.
Section~\ref{sec:RGtk2:cellrenderers}. Here, we limit our discussion
to selection of rows.

\GTK\/ provides the class \class{GtkTreeSelection} to manage row
selection. Every tree view has a single instance of
\class{GtkTreeSelection}, returned by the
\method{getSelection}{GtkTreeView} method.

The usage of the selection object depends on the selection mode, i.e.,
whether multiple rows may be selected. The mode is configured with the
\method{setMode}{GtkTreeSelection} method, with values from
\code{GtkSelectionModel}, including \qcode{multiple} for allowing more
than one row to be selected and \qcode{single} for limiting selections
to a single row, or none. For example, we create a view and limit it
to single selection:
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(mtcars)
 view <- gtkTreeView(model)
 selection <- view$getSelection()
 selection$setMode("single")
\end{Sinput}
\end{Schunk}

When only a single selection is possible, the method
\method{getSelected}{GtkTreeSelection} returns the selected row as a
list, with components \code{retval} to indicate success, \code{model}
pointing to the tree model and \code{iter} representing an iterator to
the selected row in the model.
%
If our tree view is shown and a selection made, this code will
return the value in the first column:
\begin{Schunk}
\begin{Sinput}
 selected <- selection$getSelected()
 with(selected, model$getValue(iter, 0)$value)
\end{Sinput}
\begin{Soutput}
[1] 21.4
\end{Soutput}
\end{Schunk}
%
When multiple selection is permitted, then the method
\method{getSelectedRows}{GtkTreeSelection} returns a list with
the \code{model} and \code{retval}, a list
of tree paths.

To respond to a selection, connect to the \signal{changed} signal on
\class{GtkTreeSelection}. Upon a selection, this handler will print
the selected values in the first column:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(selection, "changed", function(selection) {
   selected_rows <- selection$getSelectedRows()
   if(length(selected_rows$retval)) {
     rows <- sapply(selected_rows$retval, 
                    gtkTreePathGetIndices) + 1L
     selected_rows$model[rows, 1]
   }
 })
\end{Sinput}
\end{Schunk}

%% double click
When a row is not editable, then the double-click event or a keyboard
command triggers the \signal{row-activated} signal for the tree
view. The callback has arguments \code{tree.view} pointing to the
widget that emits the signal, \code{path} storing a tree path of the
selected row, and \code{column} containing the tree view column. The
column number is not returned. If that is of interest, it can be
passed in via the user data argument, or matched against the children
of the tree view through a command like
\begin{Schunk}
\begin{Sinput}
 sapply(view$getColumns(), function(i) i == column)
\end{Sinput}
\end{Schunk}

\subsection{Sorting}
\label{sec:RGtk2:mvc:proxies}

A common GUI feature is sorting a table widget by column. By
convention, the user clicks on the column header to toggle
sorting. \class{GtkTreeView} supports this interaction, although the
actual sorting occurs in the model. Any model that implements the
\class{GtkTreeSortable} interface supports
sorting. \class{RGtkDataFrame} falls into this category. When
\class{GtkTreeView} is directly attached to a sortable model, it is
only necessary to inform each view column of the model column to use
for sorting when the header is clicked:
\begin{Schunk}
\begin{Sinput}
 column <- view$getColumn(0)
 column$setSortColumnId(0)
\end{Sinput}
\end{Schunk}
%
In the above, clicking on the header of the first view column will
sort by the first model column. Behind the scenes,
\class{GtkTreeViewColumn} will set its sort column as the sort column
on the model, i.e.:
\begin{Schunk}
\begin{Sinput}
 model$setSortColumnId(0, "ascending")
\end{Sinput}
\end{Schunk}

Some models, however, do not implement \class{GtkTreeSortable}, such
as \class{GtkTreeModelFilter}, introduced in the next section. Also,
sorting a model permanently changes the order of its rows, which may
be undesirable in some cases. The solution is to proxy the original
model with a sortable model. The proxy obtains all of its data from the
original model and reorders the rows according to the order of the
sort column. \GTK\/ provides \class{GtkTreeModelSort} for this:
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(Cars93)
 sorted_model <- gtkTreeModelSortNewWithModel(model)
 view <- gtkTreeView(sorted_model)
 mapply(view$insertColumnWithAttributes,
        position = -1,
        title = colnames(model),
        cell = list(gtkCellRendererText()),
        text = seq_len(ncol(model)) - 1)
 sapply(seq_len(ncol(model)), function(i)
        view$getColumn(i - 1)$setSortColumnId(i - 1))
\end{Sinput}
\end{Schunk}
%
When the user sorts the table, the underlying \code{store} will not be
modified. 

\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{fig-RGtk2-sortable-treeview}
  \caption{When a sortable model is passed to the treeview, one can click on the column headers to sort the data. The "Type" column has a custom sort function applied.}
  \label{fig:RGtk2-sortable-treeview}
\end{figure}


The default sorting function can be changed by calling the method
\method{setSortFunc}{GtkTreeSortable} on a sortable model.  The
following function shows how a special sort for the \code{Type} of car
can be implemented (Figure~\ref{fig:RGtk2-sortable-treeview}).
\begin{Schunk}
\begin{Sinput}
 f <- function(model, iter1, iter2, user.data) {
   types <- c("Compact", "Small", "Sporty", "Midsize", 
              "Large", "Van")
   column <- user.data
   val1 <- model$getValue(iter1, column)$value
   val2 <- model$getValue(iter2, column)$value
   as.integer(match(val1, types) - match(val2, types))
 }
 sorted_model$setSortFunc(sort.column.id = 3 - 1, sort.func = f, 
                          user.data = 3 - 1)
\end{Sinput}
\end{Schunk}


\subsection{Filtering}
\label{sec:RGtk2:mvc:filtering}

The previous section introduced the concept of a proxy model in
\class{GtkTreeModelSort}. Another common application of proxying is
filtering.  For filtering via a proxy model, \GTK\/ provides the
\class{GtkTreeModelFilter} class. The basic idea is that an extra
column in the base model stores logical values to indicate if a row
should be visible. The index of that column is passed to the filter
model, which provides only those rows where the filter column is
\code{TRUE}.

This is the basic usage:
\begin{Schunk}
\begin{Sinput}
 DF <- Cars93
 model <- rGtkDataFrame(cbind(DF, .visible=rep(TRUE, nrow(DF))))
 filtered_model <- model$filter()
 filtered_model$setVisibleColumn(length(DF))          # 0-based
 view <- gtkTreeView(filtered_model)
 ## Adjust filter
 model[,".visible"] <- DF$MPG.highway >= 30
\end{Sinput}
\end{Schunk}
%
The constructor of the filter model is \function{gtkTreeModelFilter},
which, somewhat coincidentally, also works as a method on the base
model, i.e., \code{model\$filter()}. To retrieve the original model
from the filter, call its \code{getModel} method. The method
\method{setVisibleColumn}{GtkTreeModelFilter} specifies which column
in the model holds the logical values.  To customize filtering, one
can register a function with \method{setVisibleFunc}{gtkTreeModelFilter}. The callback,
given a row pointer, should return \code{TRUE} if the row passes the
filter, see Example~\ref{ex:RGtk2-variable-selection}. A filter model
may be treated as any other tree model, including attachment to a
\class{GtkTreeView}.


%% filter


\begin{example}{Using filtering}{ex:RGtk2-filtered}
This example shows how to use \class{GtkTreeModelFilter} to filter
rows according to whether they match a value entered into a text entry
box. The end result is similar to an entry widget with completion.


\begin{figure}
  \centering
  \includegraphics[width=.45\textwidth]{ex-RGtk2-filtered}
  \caption{Example of a data model filtered by values typed into a
    text-entry widget.}
  \label{fig:RGtk2-filtered}
\end{figure}

First, we create a data frame. The
\code{visible} column will be added to the \code{rGtkDataFrame}
instance to adjust the visible rows.
\begin{Schunk}
\begin{Sinput}
 DF <- data.frame(state.name)
 DF$visible <- rep(TRUE, nrow(DF))
 model <- rGtkDataFrame(DF)
\end{Sinput}
\end{Schunk}

The filtered model needs to have the column specified that contains
the logical values; in this example, it is the last column.
\begin{Schunk}
\begin{Sinput}
 filtered_model <- model$filter()
 filtered_model$setVisibleColumn(ncol(DF) - 1)      # offset
 view <- gtkTreeView(filtered_model)
\end{Sinput}
\end{Schunk}

Next, we create a basic view of a single column:
\begin{Schunk}
\begin{Sinput}
 view$insertColumnWithAttributes(0, "Col", 
                  gtkCellRendererText(), text = 0)
\end{Sinput}
\end{Schunk}

An entry widget will be used to control the filtering. In the
callback, we adjust the \code{visible} column of the
\code{rGtkDataFrame} instance to reflect the rows to be shown. When
\code{val} is an empty string, the result of \function{grepl} is 
\code{TRUE}, so all rows will be shown.
\begin{Schunk}
\begin{Sinput}
 entry <- gtkEntry()
 gSignalConnect(entry, "changed", function(entry, user.data) {
   pattern <- entry$getText()
   DF <- user.data$getModel()
   values <- DF[, "state.name"]
   DF[, "visible"] <- grepl(pattern, values)
 }, data=filtered_model)
\end{Sinput}
\end{Schunk}


Figure~\ref{fig:RGtk2-filtered} shows the two widgets placed within a
simple GUI.
\end{example}

\subsection{Cell renderer details}
\label{sec:RGtk2:cellrenderers}

The values in a tree model are rendered in a rectangular cell by the
derivatives of \class{GtkCellRenderer}. Cell renderers are
interactive, in that they also manage editing and activation of cells.

A cell renderer is independent of any data model. Its rendering role
is limited to drawing into a specified rectangular region according to
its current property values. An object that implements the
\class{GtkCellLayout} interface, like \class{GtkTreeViewColumn} and
\class{GtkComboBox} (see Section~\ref{sec:RGtk2:mvc:combobox}),
associates a set of \emph{attributes} with a cell renderer. An
attribute is a link between an aesthetic property of a cell renderer
and a column in the data model. When the \class{GtkCellLayout} object
needs to render a particular cell, it configures the properties of the
renderer with the values from the current model row, according to the
attributes. Thus, the mapping from data to visualization depends on
the class of the renderer instance, its explicit property settings,
and the attributes associated with the renderer in the cell layout.

For example, to render text, a \class{GtkCellRendererText} is
appropriate. The \code{text} property is usually linked via an
attribute to a text column in the model, as the text would vary from
row to row. However, the background color (the \code{cell-background}
property) might be common to all rows in the column and thus is set
explicitly, without use of an attribute:
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererText()
 cell_renderer['cell-background'] <- "gray"
\end{Sinput}
\end{Schunk}

The base class \class{GtkCellRenderer} defines a number of properties
that are common to all rendering tasks. The \code{xalign} and
\code{yalign} properties specify the alignment, i.e., how to position
the rendered region when it does not fill the entire cell. The
\code{cell-background} property indicates the color for the entire
cell background.

The rest of this section describes each type of cell renderer, as well
as some advanced features.

%% text/ numbers
\paragraph{Text cell renderers}

\constructor{GtkCellRendererText} displays text and numeric
values. Numeric values in the model are shown as strings.  The most
important property is \code{text}, the actual text that is
displayed. Other properties control the display of the text, such as
the font \code{family} and \code{size}, the \code{foreground} and
\code{background} colors, and whether to \code{ellipsize} or
\code{wrap} the text if there is not enough space for display.  For
example, we display right-aligned text in a Helvetica font:
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererText()
 cell_renderer['xalign'] <- 1          # default 0.5 = centered
 cell_renderer['family'] <- "Helvetica"  
\end{Sinput}
\end{Schunk}

When an attribute links the \code{text} property to a numeric column
in the model, the property system automatically converts the number to
its string representation. This occurs according to the same logic
that \R\/ follows to print numeric values, so options like
\code{scipen} and \code{digits} are considered. See the ``Overriding
attribute mappings'' paragraph below for further customization.

\paragraph{Editable cells} When the \code{editable} property of a text
cell (or \code{activatable} property of a toggle cell) is set to
\code{TRUE}, then the cell contents can be changed. This allows the
user to make changes to the underlying model through the GUI. Although
the view automatically reflects changes made to the model, the reverse
is not true. A callback must be assigned to the \code{editable}
(\code{toggled}) signal for the cell renderer to implement the
change. The callback for the \qcode{edited} signal has arguments
\code{renderer}, \code{path} for the path of the selected row (as a
string), and \code{new.text} containing the value of the edited text
as a string. These arguments do not include the tree view object nor
the column index, so these should be provided by some other means,
e.g., from the enclosing environment of the handler.
For example, here is how one can update an \code{RGtkDataFrame} model
from within the callback:
\begin{Schunk}
\begin{Sinput}
 cell_renderer['editable'] <- TRUE
 gSignalConnect(cell_renderer, "edited", 
        f=function(cell_renderer, path, newtext, user.data) {
          i <- as.numeric(path) + 1
          j <- user.data$column
          model <- user.data$model
          model[i, j] <- newtext
        }, data=list(model=store, column=1))
\end{Sinput}
\end{Schunk}
% 
Before using editable cells to create a data frame editor, one should
see if the editor provided by the \function{gtkDfEdit} in the
\pkg{RGtk2Extras} package satisfies the requirements.

Users may expect that once a cell is edited, the next cell is then set
up to be edited. In order to do this, one must advance the cursor and
activate editing of the next cell. For \class{GtkTreeView}, this is
implemented by the \method{setCursor}{GtkTreeView} method.

\begin{example}{Using a table to gather arguments}{ex:RGtk2-options-in-table}

This example shows one way to gather arguments or options using an
editable cell in a table, rather than a separate text entry
widget. Tables can provide compact entry areas in a familiar
interface.

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{fig-RGtk2-option-editor.png}
  \caption{A tree view used to gather arguments for a call to \function{title}.}
  \label{fig:RGtk2-option-editor}
\end{figure}

For this example we collect values for arguments to the
\function{title} function. We first create a data frame with the
argument name and default value, along with some additional values:
\begin{Schunk}
\begin{Sinput}
 opts <- c("main", "sub", "xlab", "ylab", "line", "outer")
 DF <- data.frame(option = opts,
            value = c("", "", "", "", "0", "FALSE"),
            class = c(rep("character", 4), "integer", "logical"),
            edit_color = rep("gray95", 6),
            dirty = rep(FALSE, 6),
            stringsAsFactors = FALSE)
\end{Sinput}
\end{Schunk}
%
Unfortunately, we need to coerce the default values to character, in
order to store them in a single column. We preserve the class in the
\code{class} column, for coercion later. The \code{edit\_color} and
\code{dirty} columns are related to editing and explained later.
%

Now we create our model and configure the first column:
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(DF)
 view <- gtkTreeView(model)
 ##
 cell_renderer <- gtkCellRendererText()
 cell_renderer['background'] <- 'gray80'
 view$insertColumnWithAttributes(position = -1,
                                 title = "Option",
                                 cell = cell_renderer,
                                 text = 1 - 1)
\end{Sinput}
\end{Schunk}
%
The first column has a special background color which we specify
below, which indicates that the cells are not editable.
The second column is editable and has a background color that is
state dependent and indicates if a cell has been edited (The
\code{xlab} column in Figure~\ref{fig:RGtk2-option-editor}):
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererText()
 cell_renderer['editable'] <- TRUE
 view$insertColumnWithAttributes(position = -1,
                                 title = "Value",
                                 cell = cell_renderer,
                                 text = 2 - 1,
                                 background = 4 - 1
                                 )
\end{Sinput}
\end{Schunk}

To attach the view to the model, we connect the cell renderer to the
\signal{edited} signal. Here we use the \code{class} value to format
the text and then set the background color and \code{dirty} flag of the
entry. The latter allows one to easily find the values which were edited.
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(cell_renderer, "edited", 
     function(cell_renderer, path, new.text, user.data) {
       model <- user.data$model
       i <- as.numeric(path) + 1; j <- user.data$column
       val <- as(new.text, model[i, 'class'])
       model[i,j] <- as(val, "character")   
       model[i, 'dirty'] <- TRUE                 # mark dirty
       model[i, 'edit_color'] <- 'gray70'        # change color
     }, data=list(model=model, column=2))
\end{Sinput}
\end{Schunk}

A simple window displays our GUI.
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show=FALSE)
 window['title'] <- "Option editor"
 window$setSizeRequest(300,500)
 scrolled_window <- gtkScrolledWindow()
 window$add(scrolled_window)
 scrolled_window$add(view)
 window$show()
\end{Sinput}
\end{Schunk}

Implementing this into a GUI requires writing a function to map the
model values into the appropriate call to the \function{title} function. The
\code{dirty} flag makes this easy, but this is a task we do not pursue
here. Instead we add a bit of extra detail by providing a tooltip.

%% ML: This section makes me uncomfortable, since it's relying on very
%% volatile code. Internal routines from a package in active
%% development, which in turn rely on undocumented and internal
%% features of R.
\paragraph{Tooltips}
For this example, our function has built-in documentation. Below we
use an internal function from the \pkg{helpr} package\footnote{It is
  important to note that we are calling internal routines of a package
  still under active development, which in turn relies on volatile
  features of R. In general, such practice can lead to maintenance
  headaches.  The purpose of this example is only to provide a natural
  demonstration of tooltips on a tree view.} to extract the
description for each of the arguments. We leave this in a list,
\code{descs}, for later lookup.
\begin{Schunk}
\begin{Sinput}
 require(helpr, quietly=TRUE)
 package <- "graphics"; topic <- "title"
 rd <- helpr:::parse_help(helpr:::pkg_topic(package, topic), 
                          package = package)
 descs <- rd$params$args
 names(descs) <- sapply(descs, function(i) i$param)
\end{Sinput}
\end{Schunk}

For many widgets, adding a
tooltip is as easy as calling
\method{setTooltipText}{GtkWidget}. However, it is more complicated in
a tree view, as each cell should get a different tip.  To add tooltips
to the tree view we first indicate that we want tooltips, then connect
to the \signal{query-tooltip} signal to implement the tooltip:
\begin{Schunk}
\begin{Sinput}
 view["has-tooltip"] <- TRUE
 gSignalConnect(view, "query-tooltip", 
        function(view, x, y, key_mode, tooltip, user.data) {
          out <- view$getTooltipContext(x, y, key_mode)
          if(out$retval) {
            model <- view$getModel()
            i <- as.numeric(out$path$toString()) + 1
            val <- model[i, "option"]
            txt <- descs[[val]]$desc
            txt <- gsub("code>","b>", txt)  # no code in Pango
            tooltip$setMarkup(txt)
            TRUE
          } else {
            FALSE                           # no tooltip
          }
        })
\end{Sinput}
\end{Schunk}
%
Within this callback we check if we have the appropriate context (we
are in a row), then, if so, use the path to find the description to
set in the tooltip. The descriptions use HTML for markup, but the
tooltip only uses Pango. As the \code{code} tag is not PANGO, we
change to a bold tag using \function{gsub}.
\end{example}

%% XXX JV Add in an editable table example here, mention
%% RGtk2Extras:::gtkDfEdit

%% perhaps could be adapted to demonstrate the above
% \begin{example}{A basic usage of displaying a data frame using a tree view}{ex:RGtk2-minimal-rGtkDataFrame}
%   \SweaveInput{ex-RGtk2-minimal-rGtkDataFrame}
% \end{example}

%% combo
\paragraph{Combo and spin cell renderers}

\class{GtkCellRendererCombo} and \class{GtkCellRendererSpin} allow
editing a text cell with a combo box or spin button,
respectively. Populating the combo box menu requires specifying two
properties: \code{model} and \code{text-column}. The menu items are
retrieved from the \class{GtkTreeModel} given by \code{model} at the
column index given by \code{text-column}.  If \code{has-entry} is
\code{TRUE}, a combo box entry is displayed.
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererCombo()
 model <- rGtkDataFrame(state.name)
 cell_renderer['model'] <- model
 cell_renderer['text-column'] <- 0
 cell_renderer['editable'] <- TRUE                  # needed
\end{Sinput}
\end{Schunk}
%
The spin button editor is configured by setting a
\class{GtkAdjustment} on the \code{adjustment} property.


The \signal{changed} signal is emitted when an items is selected in
the combo box. The spin cell renderer inherits the \signal{edited}
signal from \class{GtkCellRendererText}.

%% pixbuf
\paragraph{Pixbuf cell renderers}

To display an image in a cell, \class{GtkCellRendererPixbuf} is
appropriate. The image is specified through one of these properties:
\code{stock-id}, a stock identifier; \code{icon-name}, the name of a
themed icon; or \code{pixbuf}, an actual \code{GdkPixbuf} object,
holding an image in memory. Using a \class{list}, one can store a
\class{GdkPixbuf} in a \class{data.frame}, and thus an
\class{RGtkDataFrame}. This is demonstrated in the next example.

% <<rgtk2-mvc-pixbuf-in-df>>=
% library(RGtk2)
% apple <- gdkPixbuf(filename = imagefile("apple-red.png"))[[1]]
% floppy <- gdkPixbuf(filename = imagefile("floppybuddy.gif"))[[1]]
% logo <- gdkPixbuf(filename = imagefile("rgtk-logo.gif"))[[1]]
% rdf <- rGtkDataFrame(data.frame(image = I(list(apple, floppy, logo))))
% view <- gtkTreeView(rdf)
% view$insertColumnWithAttributes(0, "image", gtkCellRendererPixbuf(), pixbuf = 0)
% win <- gtkWindow()
% win$add(view)
% @


%% JV redid, a tighter programmed
\begin{example}{A variable selection widget}{ex:RGtk2-variable-selection}
%%
%% ML: John, I changed this to explicitly treat the selected and
%% unselected widgets, instead of looping over the pairs. It just
%% seemed like looping over two discrete things added unnecessary
%% complexity. Sure, the code is a little more verbose now, but it's
%% probably more readable. The other big change was using one model
%% and a custom filter.
%% JV: Cool -- thanks. I use s/mapply to reinforce symmetry
%%
This example shows how to create a GUI for selecting variables from a
data frame. The GUI is based on two lists. The left one indicates the
variables that can be selected, and the right shows the variables that
have been selected. An icon, indicating the variable type, is placed
next to the variable name (Figure~\ref{fig:RGtk2-select-variables}.) A
similar mechanism is part of the SPSS model specification GUI of
Figure~\ref{fig:GUI:spss-11-term-selection}. For illustration purposes
we use the \code{Cars93} data set.
\begin{Schunk}
\begin{Sinput}
 DF <- get(data(Cars93, package="MASS"))
\end{Sinput}
\end{Schunk}


\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{fig-RGtk2-select-variables}
  \caption{Illustration of an interface to select one or more
    variables. An icon is used in the table view to indicate the
    variable type.}
  \label{fig:RGtk2-select-variables}
\end{figure}

First, we render an icon for each variable.  The \code{make\_icon}
function from the \pkg{ProgGUIinR} package creates an icon as a
\pkg{grid} object, which we render with \pkg{cairoDevice}:
% 
\begin{Schunk}
\begin{Sinput}
 make_icon_pixmap <- function(x, ...) {
   require(grid); require(cairoDevice)
   pixmap <- gdkPixmap(drawable = NULL, width = 16, height = 16, 
                       depth = 24)
   asCairoDevice(pixmap)
   grid.newpage()
   grid.draw(make_icon(x))
   dev.off()
   gdkPixbufGetFromDrawable(NULL, pixmap, NULL, 0,0, 0,0, -1,-1)
 }
\end{Sinput}
\end{Schunk}

The two list views are based on the same underlying data model, which
contains three columns: the variable name, the icon, and whether the
variable has been selected. We construct the corresponding data frame
and wrap it in a \class{RGtkDataFrame} instance:
\begin{Schunk}
\begin{Sinput}
 model_df <- data.frame(Variables = I(sort(names(DF))),
                        icon = I(sapply(DF, make_icon_pixmap)),
                        selected = rep(FALSE, ncol(DF)))
 model <- rGtkDataFrame(model_df)
\end{Sinput}
\end{Schunk}

The first view shows only unselected variables, while the other is
limited to selected variables. Thus, each view will be based on a
different filter:
\begin{Schunk}
\begin{Sinput}
 selected_filter <- model$filter()
 selected_filter$setVisibleColumn(2)
 unselected_filter <- model$filter()
 unselected_filter$setVisibleFunc(function(model, iter) {
   !model$get(iter, 2)[[1]]
 })
\end{Sinput}
\end{Schunk}
%
The selected filter is relatively easy to define, using
\code{selected} as the visible column. For the unselected filter, we
need to define a custom visible function that inverts the
\code{selected} column.

Next, we create a view for each filter:
\begin{Schunk}
\begin{Sinput}
 views <- list()
 views$unselected_view <- gtkTreeView(unselected_filter)
 views$selected_view <- gtkTreeView(selected_filter)
 ##
 sapply(views, function(view) {
   selection <- view$getSelection()
   selection$setMode('multiple')
 })
\end{Sinput}
\end{Schunk}

Each cell needs to display both an icon and a label.  This is achieved
by packing two cell renderers into the column:
\begin{Schunk}
\begin{Sinput}
 make_view_column <- function() {
   column <- gtkTreeViewColumn()
   column$setTitle("Variable")
   column$packStart(cell_renderer <- gtkCellRendererPixbuf())
   column$addAttribute(cell_renderer, "pixbuf", 1L)
   column$packStart(cell_renderer <- gtkCellRendererText())
   column$addAttribute(cell_renderer, "text", 0L)
   column
 }
 sapply(views, function(view) 
        view$insertColumn(make_view_column(), 0))
\end{Sinput}
\end{Schunk}

For later use we extend the API for a tree view -- one method to find
the selected indices ($1$-based) and one to indicate if there is a
selection: 
\begin{Schunk}
\begin{Sinput}
 ## add to the gtkTreeView API for convenience
 gtkTreeViewSelectedIndices <- function(object) {
   model <- object$getModel()          # Filtered!
   paths <- object$getSelection()$getSelectedRows()$retval
   path_strings <- sapply(paths, function(i) {
     model$convertPathToChildPath(i)$toString()
   })
   if(length(path_strings) == 0)
     integer(0)
   else
     as.numeric(path_strings) + 1 # 1-based
 }
 ## does object have selection?
 gtkTreeViewHasSelection <-
   function(obj) length(obj$selectedIndices()) > 0
\end{Sinput}
\end{Schunk}

Now we create the buttons and connect to the \code{clicked}
signal. The handler moves the selected values to the other list by
toggling the \code{selected} variable:
\begin{Schunk}
\begin{Sinput}
 buttons <- list()
 buttons$unselect_button <- gtkButton("<")
 buttons$select_button <- gtkButton(">")
 toggleSelectionOnClick <- function(button, view) {
   gSignalConnect(button, "clicked", function(button) {
     message("clicked")
     ind <- view$selectedIndices()
     model[ind, "selected"] <- !model[ind, "selected"]
   })
 }
 sapply(1:2, function(i) toggleSelectionOnClick(buttons[[i]], 
                                                views[[3-i]]))
\end{Sinput}
\end{Schunk}
%
We only want our buttons sensitive if there is a possible move. This
is determined by the presence of a selection:
\begin{Schunk}
\begin{Sinput}
 sapply(buttons, gtkWidgetSetSensitive, FALSE)
 trackSelection <- function(button, view) {
   gSignalConnect(view$getSelection(), "changed", 
      function(x) button['sensitive'] <- view$hasSelection())
 }
 sapply(1:2, function(i) trackSelection(buttons[[i]], 
                                        views[[3-i]]))
\end{Sinput}
\end{Schunk}

We now layout our GUI using a horizontal box, into which is packed the
views and a box holding the selection buttons. The views
will be scrollable, so we place them in scrolled windows:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show=FALSE)
 window$setTitle("Select variables example")
 window$setDefaultSize(600, 400)
 hbox <- gtkHBox()
 window$add(hbox)
 ## scrollwindows
 scrolls <- list()
 scrolls$unselected_scroll <- gtkScrolledWindow()
 scrolls$selected_scroll <- gtkScrolledWindow()
 mapply(gtkContainerAdd, object = scrolls, widget = views)
 mapply(gtkScrolledWindowSetPolicy, scrolls, 
        "automatic", "automatic")
 ## buttons
 button_box <- gtkVBox()
 centered_box <- gtkVBox()
 button_box$packStart(centered_box, expand = TRUE, fill = FALSE)
 centered_box$setSpacing(12)
 sapply(buttons, centered_box$packStart, expand = FALSE)
 ##
 hbox$packStart(scrolls$unselected_scroll, expand = TRUE)
 hbox$packStart(button_box, expand = FALSE)
 hbox$packStart(scrolls$selected_scroll, expand = TRUE)
\end{Sinput}
\end{Schunk}

Finally, we show the top-level window:
\begin{Schunk}
\begin{Sinput}
 window$show()
\end{Sinput}
\end{Schunk}


\end{example}

\paragraph{Toggle cell renderers}

Binary data can be represented by a toggle. The
\constructor{gtkCellRendererToggle} will create a check box in the
cell that will appear checked if the \code{active} property is
\code{TRUE}. If an attribute is defined for the property, then changes
in the model will be reflected in the view. More work is required to
modify the model in response to user interaction with the view. The
\code{activatable} attribute for the cell must be \code{TRUE} in order
for it to receive user input. The programmer then needs to connect to the
\signal{toggled} to update the model in response to changes in the
active state.
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererToggle()
 cell_renderer['activatable'] <- TRUE   # cell can be activated
 cell_renderer['active'] <- TRUE
 gSignalConnect(cell_renderer, "toggled", function(w, path) {
   model$active[as.numeric(path) + 1] <- w['active']
 })
\end{Sinput}
\end{Schunk}

To render the toggle as a radio button instead of a check box, set the
\code{radio} property to \code{TRUE}. Again, the programmer is
responsible for implementing the radio button logic via the
\code{toggled} signal.

\begin{example}{Displaying a check box column in a tree
    view}{ex:RGtk2-add-toggle-to-df}
This example demonstrates the construction of a GUI for selecting one
or more rows from a data frame. We will display a list of the installed
packages that can be upgraded from CRAN, although this code is
trivially generalizable to any list of choices. The user selects a row
by clicking on a 
check box produced by a toggle cell renderer.






To get the installed packages that can be upgraded, we use some of the
functions provided by the  \pkg{utils} package.
\begin{Schunk}
\begin{Sinput}
 old_packages <- 
   old.packages()[,c("Package", "Installed", "ReposVer")]
 DF <- as.data.frame(old_packages)
\end{Sinput}
\end{Schunk}


This function will be called on the selected rows. Here, we simply
call \function{install.packages} to update the selected packages.
\begin{Schunk}
\begin{Sinput}
 doUpdate <- function(old_packages) 
   install.packages(old_packages$Package)
\end{Sinput}
\end{Schunk}

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-RGtk2-add-toggle-to-df.png}
  \caption{A GUI to select packages using checkboxes rendered with a \class{GtkCellRenererToggle} instance.}
  \label{fig:RGtk2-add-toggle-to-df}
\end{figure}
To display the data frame, we first append a column to the data frame
to store the selection information and then create a corresponding
\class{RGtkDataFrame}.
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(cbind(DF, .toggle=rep(FALSE, nrow(DF))))
\end{Sinput}
\end{Schunk}

Our tree view shows each text column using a simple text cell renderer,
except for the first column that contains the check boxes for selection.
\begin{Schunk}
\begin{Sinput}
 view <- gtkTreeView()
 # add toggle
 cell_renderer <- gtkCellRendererToggle()
 view$insertColumnWithAttributes(0, "", cell_renderer, active = ncol(DF))
 cell_renderer['activatable'] <- TRUE
 gSignalConnect(cell_renderer, "toggled", 
                function(cell_renderer, path, user.data) {
                  view <- user.data
                  row <- as.numeric(path) + 1
                  model <- view$getModel()
                  n <- dim(model)[2]
                  model[row, n] <- !model[row, n]
                }, data=view)
\end{Sinput}
\end{Schunk}

The text columns are added in one go:
\begin{Schunk}
\begin{Sinput}
 mapply(view$insertColumnWithAttributes, -1, colnames(DF), 
        list(gtkCellRendererText()), text = seq_along(DF) -1L)
\end{Sinput}
\end{Schunk}
%
Finally, we connect the store to the model.
\begin{Schunk}
\begin{Sinput}
 view$setModel(model)
\end{Sinput}
\end{Schunk}
%
To allow the user to initiate the action, we create a button and
assign a callback. We pass in the view, rather than the model, in case
the model would be recreated by the \code{doUpdate} call. In a real
application, once a package is upgraded it would be removed from the
display.
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton("Update packages")
 gSignalConnect(button, "clicked", function(button, data) {
   view <- data
   model <- view$getModel()
   old_packages <- 
     model[model[, ncol(model)], -ncol(model), drop = FALSE]
   doUpdate(old_packages)
 }, data=view)
\end{Sinput}
\end{Schunk}


Our basic GUI places the view into a box container that also holds the
button to initiate the action.
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE)
 window$setTitle("Installed packages that need upgrading")
 window$setSizeRequest(300, 300)
 vbox <- gtkVBox(); window$add(vbox)
 scrolled_window <- gtkScrolledWindow()
 vbox$packStart(scrolled_window, expand = TRUE, fill = TRUE)
 scrolled_window$add(view)
 scrolled_window$setPolicy("automatic", "automatic")
 vbox$packStart(button, expand = FALSE)
 window$show()
\end{Sinput}
\end{Schunk}
\end{example}

%% progress bars
\paragraph{Progress cell renderers}

To visually communicate progress within a cell, both progress bars and
spinner animations are supported. These modes correspond to
\class{GtkCellRendererProgress} and \class{GtkCellRendererSpinner},
respectively.

In the case of \class{GtkCellRendererProgress}, its \code{value}
property takes a value between $0$ and $100$ indicating the amount
finished, with a default value of $0$. Values out of this range will
be signaled by an error message.  For example,
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererProgress()
 cell_renderer["value"] <- 50
\end{Sinput}
\end{Schunk}

For indicating progress in the absence of a definite end point,
\class{GtkCellRendererSpinner} is more appropriate. The spinner is
displayed when the \code{active} property is \code{TRUE}. Increment
the \code{pulse} property to drive the animation.

%% numbers
\paragraph{Overriding attribute mappings}

The default behavior for mapping model values to a renderer property
is simple: values are extracted from the model and passed directly to
the cell renderer property. If the data types are different, such as a
numeric value for a string property, the value is converted using
low-level routines defined by the property system. It is sometimes
desirable to override this mapping with more complex logic.

For example, conversion of numbers to strings is a non-trivial
task. Although the logic in the \R\/ print system often performs
acceptably, there is certainly room for customization. One example is
aligning floating point numbers by fixing the number of decimal
places. This could be done in the model (e.g., using
\function{sprintf} to format and coerce to character
data). Alternatively, one could preserve the integrity of the data and
perform the conversion during rendering. This requires intercepting
the model value before it is passed to the cell renderer. 

In the specific case of \class{GtkTreeView}, it is possible to specify a
callback that overrides this step.  The callback, of type
\class{GtkTreeCellDataFunc}, is passed arguments for the tree view
column, the cell renderer, the model, an iterator pointing to the row
in the model and, optionally, an argument for user data. The function
is tasked with setting the appropriate attributes of the cell
renderer. For example, this callback would format floating point
numbers:
\begin{Schunk}
\begin{Sinput}
 func <- function(column, cell_renderer, model, iter, data) {
   val <- model$getValue(iter, 0)$value
   f_val <- sprintf("%.3f", val)
   cell_renderer['text'] <- f_val
   cell_renderer['xalign'] <- 1
 }
\end{Sinput}
\end{Schunk}
%
The function then needs to be registered with a
\class{GtkTreeViewColumn} that is rendering a numeric column from the model:
\begin{Schunk}
\begin{Sinput}
 view <- gtkTreeView(rGtkDataFrame(data.frame(rnorm(100))))
 cell_renderer <- gtkCellRendererText()
 view$insertColumnWithAttributes(0, "numbers", cell_renderer, 
                                 text = 0)
 column <- view$getColumn(0)
 column$setCellDataFunc(cell_renderer, func)
\end{Sinput}
\end{Schunk}
%
The last line is the key: calling
\method{setCellDataFunc}{GtkTreeViewColumn} registers our custom
formatting function with the view column.

One drawback with the use of such functions is that \R\/ code is
executed every time a cell is rendered. If performance matters,
consider pre-converting the data in the model or tweaking the
\code{options} in \R\/ for printing real numbers, namely \code{scipen}
and \code{digits}.

For customizing rendering further, and in the general case beyond
\class{GtkTreeView}, one could implement a new type of
\class{GtkCellRenderer}.  See Chapter~\ref{sec:gtk:extending-classes}
for more details on extending \GTK\/ classes.

%% This function will be set for the tree view column and illustrated in Example~\ref{ex:RGtk2:rGtk2DataFrame}.
%% editable cells 

\section{Display of hierarchical data}
\label{sec:RGtk2:mvc:GtkTreeStore}

Although the \code{RGtkDataFrame} model is a convenient implementation
of \class{GtkTreeModel}, it has its limitations. Primary among them is
its lack of support for hierarchical data. \GTK\/ implements
\class{GtkTreeModel} with \class{GtkListStore} and
\class{GtkTreeStore}, which respectively store non-hierarchical and
hierarchical tabular data. \class{GtkListStore} is a flat table,
while \class{GtkTreeStore} organizes the table into a hierarchy. Here,
we discuss \class{GtkTreeStore}.

\subsection{Loading hierarchical data}
  
%% ML: I'm pretty sure that RGtkDataFrame will support the same types
%% of values as GtkListStore. It's just a little tricky to get a
%% column of GdkPixbuf externalptr's into a data.frame. Much easier to
%% use a character vector and associate it with the stock.id property
%% of GtkCellRendererPixbuf, as long as the images are registered icons.

%% construction
A tree store is constructed using \constructor{gtkTreeStore}. The
column types are specified through a character vector at the time of
construction. The specification uses ``GTypes'' such as
\code{gchararray} for character data, \code{gboolean} for logical
data, \code{gint} for integer data, \code{gdouble} for numeric data,
and \code{GObject} for \GTK\/ objects, such as pixbufs.

\begin{example}{Defining a tree}{eg:RGtk2:tree-store}
  Below, we create a tree based on the \code{Cars93} dataset, where
  the car models (\code{Model}) are organized by manufacturer
  (\code{Manufacturer}), i.e., each model row is the child of its
  manufacturer row:
\begin{Schunk}
\begin{Sinput}
 model <- gtkTreeStore("gchararray")
 by(Cars93, Cars93$Manufacturer, function(DF) {
   parent_iter <- model$append()
   model$setValue(parent_iter$iter, column = 0, value = 
                  DF$Manufacturer[1])
   sapply(DF$Model, function(car_model) {
     child_iter <- model$append(parent = parent_iter$iter)
     if (is.null(child_iter$retval)) 
       model$setValue(child_iter$iter, column = 0, 
                      value = car_model)
   })
 })
\end{Sinput}
\end{Schunk}
  To retrieve a value from the tree store using its path we have:
\begin{Schunk}
\begin{Sinput}
 iter <- model$getIterFromString("0:0")
 model$getValue(iter$iter, column = 0)$value
\end{Sinput}
\begin{Soutput}
[1] "Integra"
\end{Soutput}
\end{Schunk}
This obtains the first model from the first manufacturer (path \qcode{0:0}).
\end{example}



As shown in the above example, populating a tree store relies on two
functions: \method{append}{GtkTreeStore}, for appending rows, and
\method{setValue}{GtkTreeStore}, for setting row values. The iterator
to the parent row is passed to \method{append}{GtkTreeStore}. A parent
of \code{NULL}, the default, indicates that the row should be at the
top level. It would also be possible to insert rows using
\method{insert}{GtkTreeStore}, \method{insertBefore}{GtkTreeStore}, or
\method{insertAfter}{GtkTreeStore}. The
\method{setValue}{GtkTreeStore} method expects the row iterator and a
$0$-based, column index.  An entire row can be assigned through the
\method{set}{GtkTreeStore} method. The method uses positional
arguments to specify the column and the value, in alternating
fashion. The column index appears as an even argument (say $2k$) and
the corresponding value in the odd argument (say $2k+1$).  Values are
returned by the \method{getValue}{GtkListStore} method, in a list with
component \code{value} storing the value.

Traversing a tree store is most easily achieved through the use of
\class{GtkTreeIter}, introduced previously in the context of flat
tables. Here we perform a depth-first traversal of our \code{Cars93}
model to obtain the model values: 
\begin{Schunk}
\begin{Sinput}
 iter <- model$getIterFirst()
 models <- NULL
 while(iter$retval) {
   child_iter <- model$iterChildren(iter$iter)
   while(child_iter$retval) {
     models <- c(models, model$get(child_iter$iter, 0)[[1]])
     child_iter$retval <- model$iterNext(child_iter$iter)
   }
   iter$retval <- model$iterNext(iter$iter)
 }
\end{Sinput}
\end{Schunk}
%
The hierarchical structure introduces the method
\method{iterChildren}{GtkTreeModel} for obtaining an iterator to the
first child of a row. As with other methods returning iterators, the
return value is a list, with the \code{retval} component indicating
the validity of the iterator, stored in the \code{iter} component. The
method \method{iterParent}{GtkTreeModel} performs the reverse,
iterating from child to parent.

%% JV can add back in such a graphic. Took out for now.
% \begin{figure}
%   %% \centering
%   \includegraphics[width=.7\textwidth]{traverse-tree}
%   \caption{[REPLACEME!] Graphical illustration of the functions used
%     by iters to traverse a tree store. }
%   \label{fig:traverse-iter}
% \end{figure}

\paragraph{Row manipulations}
Rows within a store can be rearranged using several methods. Call the
\method{swap}{GtkTreeStore} method to swap rows referenced by their
iterators.  The methods \method{moveAfter}{GtkTreeStore} and
\method{moveBefore}{GtkTreeStore} move one row after or before
another, respectively.  The \method{reorder}{GtkTreeStore} method
totally reorders the rows under a specified parent given a vector of
row indices, like that returned by \function{order}.
%% clearing contents
Once added, rows may be removed using the
\method{remove}{GtkTreeStore} method. To remove every row, call the
\method{clear}{GtkTreeStore} method.

\subsection{Displaying data as a tree}
\label{sec:RGtk2:mvc:display-tree}

Once a hierarchical dataset has been loaded into a
\class{GtkTreeModel} implementation like \class{GtkTreeStore}, it can
be passed to a \class{GtkTreeView} widget for display as a
tree. Indeed, this is the same widget that displayed our flat data
frame in the previous section. As before, \class{GtkTreeView}
displays the \class{GtkTreeModel} as a table; however, it now adds
controls for expanding and collapsing nodes where rows are nested.

The user can click to expand or collapse a part of the tree. These
actions trigger the emission of the signals \code{row-expanded} and
\code{row-collapsed}, respectively.

\begin{example}{A simple tree display}{eg:RGtk2-simple-tree}
Here, we demonstrate the application of \class{GtkTreeView} to the
display of hierarchical data. We will use the model constructed in
Example~\ref{eg:RGtk2:tree-store} from the \code{Cars93} dataset.  In
that example we defined a simple tree store from a data frame, with a
level for manufacturer and make for different cars. We refer to that
model by \code{tstore} below.


Creating a basic view is similar to that for rectangular data already presented:
\begin{Schunk}
\begin{Sinput}
 view <- gtkTreeView()
 view$insertColumnWithAttributes(0, "Make", 
            gtkCellRendererText(), text = 0)
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\begin{Sinput}
 view$setModel(model)
\end{Sinput}
\end{Schunk}


To demonstrate that \class{GtkTreeView} supports both hierarchical and
flat tabular models, we will create an analogous \class{RGtkDataFrame}
and set it on the view:
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(Cars93[,"Model", drop=FALSE])
 view$setModel(model)
\end{Sinput}
\end{Schunk}
\end{example}

%% ## dynamic. 
%% JV: Is this too much? Perhaps leave for the package?
%% ML: Probably should move this to the package.
% \begin{example}{Dynamically growing a tree}{eg:RGtk2:tree-dynamic}
%   \SweaveInput{ex-RGtk2-tree}
% \end{example}
%% % ## mapes a list, shows how to update text view
% \SweaveInput{ex-RGtk2-tree-show}

\section{Model-based combo boxes}
\label{sec:RGtk2:mvc:combobox}

Basic combo box usage was discussed in
Section~\ref{sec:RGtk2:basic-combobox}; here we discuss the more
flexible and complex approach of using an explicit data model for
storing the menu items. The item data is tabular, although it is
limited to a single column. Thus, \class{GtkTreeModel} is again the
appropriate model, and \class{RGtkDataFrame} is usually the
implementation of choice.

To construct a \class{GtkComboBox} based on a user-created model, one
should pass the model to the constructor
\constructor{gtkComboBox}. This model may be changed or set through
the \method{setModel}{GtkComboBox} method and is returned by
\method{getModel}{GtkComboBox}. Like \class{GtkTreeViewColumn},
\class{GtkComboBox} implements the \class{GtkCellLayout} interface and
thus delegates the rendering of model values to
\class{GtkCellRenderer} instances that are packed into the combo box.

The \method{getActiveIter}{GtkComboBox} returns a list containing the iterator
pointing to the currently selected row in the model.  If no row has been
selected, the \code{retval} component of the list is \code{FALSE}.
The \method{setActiveIter}{GtkComboBox} sets the currently selected
item by iterator. As discussed previously, the
\method{getActive}{GtkComboBox} and \method{setActive}{gtkComboBox}
methods behave analogously with $0$-based indices.

\begin{example}{A combo box with memory}{eg:RGtk2-combobox-entry}
%%
This example uses an editable combo box as an simple interface to the
\R\/ help system. Along the way, we record the number of times the
user searches for a page.

Our model for the combo box will be an \class{RGtkDataFrame} instance
with three columns: a function name, a string describing the
number of visits and an integer to record the number of visits. 
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(data.frame(filename = character(0), 
                                   visits = character(0), 
                                   nvisits = integer(0), 
                                   stringsAsFactors = FALSE))
\end{Sinput}
\end{Schunk}

As introduced in the previous chapter, the \class{GtkComboBoxEntry}
widget extends \class{GtkComboBox} to provide an entry widget for the
user to enter arbitrary values. To construct a combo box entry on top
of a tree model, one should pass the model, as well as the column
index that holds the textual item labels, to the
\constructor{gtkComboBoxEntry} constructor. It is not necessary to
create a cell renderer for displaying the text, as the entry depends
on having text labels and thus enforces their display. It is still
possible, of course, to add cell renderers for other model columns.
We create the combo box with this model using the first column for the
text:
\begin{Schunk}
\begin{Sinput}
 combo_box <- gtkComboBoxEntryNewWithModel(model, 
                                           text.column = 0)
\end{Sinput}
\end{Schunk}

It is not currently possible to put tooltip information on the drop
down elements of a combo box, as was done with a tree view. Instead,
we borrow from popular web browser interfaces and add textual
information about the number of visits to the drop down menu. This
requires us to pack in a new cell renderer to accompany the original
label provided by the \code{gtkComboBoxEntry} widget:
\begin{Schunk}
\begin{Sinput}
 cell_renderer <- gtkCellRendererText()
 combo_box$packStart(cell_renderer)
 combo_box$addAttribute(cell_renderer, "text", 1)
 cell_renderer['foreground'] <- "gray50"
 cell_renderer['ellipsize'] <- "end"
 cell_renderer['style'] <- "italic"
 cell_renderer['alignment'] <- "right"
\end{Sinput}
\end{Schunk}

%% JV: This first point seems like a misunderstanding on my part, but
%% I tried:
%% > m =rGtkDataFrame(data.frame(a=character(0), b=character(0), stringsAsFactors=FALSE))
%% > sapply(m[,], class)          a           b 
%% "character" "character" 
%% > m$appendRows(list(a="a", b="b"))
%% <pointer: 0x11eda4e30>
%% attr(,"interfaces")
%% [1] "GtkTreeModel"    "GtkTreeSortable"
%% attr(,"class")
%% [1] "RGtkDataFrame" "GObject"       "RGtkObject"   
%% > sapply(m[,], class)
%%        a        b 
%% "factor" "factor" 

%% ML: Just pass a data.frame to the appendRows function. The updating
%% dimensions comment was false. It was just a bug in RGtkDataFrame
%% that is now fixed in svn.

This helper function will be called each time a help page is
requested. It first updates the visit information, selects the
text for easier editing the next time round, then calls \function{help}.
\begin{Schunk}
\begin{Sinput}
 callHelpFunction <- function(combo_box, value) {
   model <- combo_box$getModel()
   ind <- match(value, model[,1,drop=TRUE])
   nvisits <- model[ind, "nvisits"] <- model[ind, "nvisits"] + 1
   model[ind, "visits"] <- 
     sprintf(ngettext(nvisits, "%s visit", "%s visits"), nvisits)
   ## select for easier editing
   combo_box$getChild()$selectRegion(start = 0, end = -1)
   help(value)
 }
 gSignalConnect(combo_box, "changed", 
                f = function(combo_box, ...) {
                  if(combo_box$getActive() >= 0) {
                    value <- combo_box$getActiveText()
                    callHelpFunction(combo_box, value)
                  }
                })
\end{Sinput}
\end{Schunk}
%

When the user enters a new value in the entry, we need to check if we
have previously accessed the item. If not, we add the value to our model.
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(combo_box$getChild(), "activate", 
        f = function(combo_box, entry, ...) {
          value <- entry$getText()
          if(!any(value == combo_box$getModel()[,1,drop=TRUE])) {
            model <- combo_box$getModel()
            tmp <- data.frame(filename = value, visits = "", 
                              nvisits = 0, 
                              stringsAsFactors = FALSE)
            model$appendRows(tmp)
          }
          callHelpFunction(combo_box, value)
        }, data = combo_box, user.data.first = TRUE)
\end{Sinput}
\end{Schunk}

We place this in a minimal GUI with a label:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE)
 window['border-width'] <- 15
 hbox <- gtkHBox(); window$add(hbox)
 hbox$packStart(gtkLabel("Help on:"))
 hbox$packStart(combo_box, expand = TRUE, fill = TRUE)
 #
 window$show()
\end{Sinput}
\end{Schunk}

An alternative approach would be to use the completion support of
\class{GtkEntry}, presented next, but we leave that as an exercise to
the reader.

\end{example}


%% JV, moved this to the first intro of comoboboxes
% \begin{example}{Modifying the values in a combobox}{eg-RGtk2-combobox-dynamic}
%   \SweaveInput{ex-RGtk2-combobox-dynamic}
% \end{example}

%% JV this is in the menu section, not really needed here
% \begin{example}{A color selection widget}{eg:RGtk2:combobox}
%   \SweaveInput{ex-RGtk2-combobox}
% \end{example}


\section{Text entry widgets with completion}
\label{sec:RGtk2:entry-completion}

Often, the number of possible choices is too large to list in a combo
box. One example is a web-based search engine: the possible search
terms, while known and finite in number, are too numerous to list. The
auto-completing text entry has emerged as an alternative to a combo
box and might be described as a sort of dynamic combo box entry widget. 
When a user enters a string, partial matches to the string are
displayed in a menu that drops down from the entry. 

The \class{GtkEntryCompletion} object implements text completion in
\GTK. An instance is constructed with
\constructor{gtkEntryCompletion}. The underlying database is a
\class{GtkTreeModel}, like \class{RGtkDataFrame}, set via the
\method{setModel}{GtkEntryCompletion} method. To connect a
\class{GtkEntryCompletion} to an actual \class{GtkEntry} widget, call
the \method{setCompletion}{GtkEntry} method on \class{GtkEntry}.  The
\code{text-column} property specifies the column containing the
completion candidates. 

There are several properties that can be adjusted to tailor the
completion feature; we mention some of them. Setting the property
\code{inline-selection} to \code{TRUE} will place the top completion
suggestion to the entry inline as the completions are scrolled
through; \code{inline-completion} will add the common prefix
automatically to the entry widget; \code{popup-single-match} is a
logical indicating if a popup is displayed on a single match;
\code{minimum-key-length} takes an integer specifying the number of
characters needed in the entry before completion is checked (the
default is $1$).

By default, the rows in the data model that match the current value of
the entry widget in a case insensitive manner are displayed. This
matching function can be overridden by setting a new \R\/ function through
the \method{setMatchFunc}{GtkEntryCompletion} method. The signature of
this function is the completion object, the string from the entry
widget (lower case), an iterator pointing to a row in the model and
optionally user data that is passed through the \code{func.data}
argument of the \code{setMatchFunc} method. This callback should
return \code{TRUE} or \code{FALSE} depending on whether that row
should be displayed in the set of completions.

%% TODO: work this example into the above
\begin{example}{Text entry with completion}{eg:RGtk2:text-entry-comletion}
This example illustrates the steps to add completion to a text entry.


We create an entry with a completion database:
\begin{Schunk}
\begin{Sinput}
 entry <- gtkEntry()
 completion <- gtkEntryCompletion()
 entry$setCompletion(completion)
\end{Sinput}
\end{Schunk}

We will use an \code{RGtkDataFrame} instance for our completion model,
taking a convenient list of names for our example.  We set the model
and text column index on the completion object and then set some
properties to customize how the completion is handled:
\begin{Schunk}
\begin{Sinput}
 model <- rGtkDataFrame(state.name)
 completion$setModel(model)
 completion$setTextColumn(0)
 completion['inline-completion'] <- TRUE
 completion['popup-single-match'] <- FALSE
\end{Sinput}
\end{Schunk}

We wish for the text search to match against any part of a string, not
only the beginning, so we define our own match function:
\begin{Schunk}
\begin{Sinput}
 matchAnywhere <- function(completion, key, iter, user.data) {
   model <- completion$getModel()
   row_value <- model$getValue(iter, 0)$value
   key <- completion$getEntry()$getText() # for case sensitivity
   grepl(key, row_value)
 }
 completion$setMatchFunc(matchAnywhere)
\end{Sinput}
\end{Schunk}
%
We get the string from the entry widget, not the passed value, as the
latter has been standardized to lower case.




\end{example}

\section{Sharing buffers between text entries}
\label{sec:RGtk2:buffer-sharing}

As of \GTK\/ version $2.18$, multiple instances of \class{GtkEntry}
can synchronize their text through a shared buffer. Each entry obtains
its text from the same underlying model, a
\class{GtkEntryBuffer}. Here, we construct two entries, with a shared
buffer:
\begin{Schunk}
\begin{Sinput}
 buffer <- gtkEntryBuffer()        
 entry1 <- gtkEntry(buffer = buffer)
 entry2 <- gtkEntry(buffer = buffer)
 entry1$setText("echo")
 entry2$getText()
\end{Sinput}
\begin{Soutput}
[1] "echo"
\end{Soutput}
\end{Schunk}
%
The change of text in \qcode{entry1} has been reflected in
\qcode{entry2}.

\section{Text views} %% text buffer
\label{sec:RGtk2:textviews}

Multiline text areas are displayed through \class{GtkTextView}
instances. These provide a view of an accompanying
\class{GtkTextBuffer}, which is the model that stores the text and
other objects to be rendered. The view is responsible for the display
of the text in the buffer and has methods for adjusting tabs, margins,
indenting, etc. The text buffer stores the actual text, and its
methods are for adding and manipulating the text.

A text view is created with \constructor{gtkTextView}.  The underlying
text buffer can be passed to the constructor. Otherwise, a buffer is
automatically created.  This buffer is returned by the method
\method{getBuffer}{GtkTextView} and may be set with the
\method{setBuffer}{GtkTextView} method. Text views provide native
scrolling support and thus are easily added to a scrolled window
(Section~\ref{sec:RGtk2:scroll-windows}). 

\begin{example}{Basic \constructor{gtkTextView} usage}{eg:RGtk2:textview-basics}
  The steps to construct a text view consist of:
\begin{Schunk}
\begin{Sinput}
 view <- gtkTextView()
 scrolled_window <- gtkScrolledWindow()
 scrolled_window$add(view)
 scrolled_window$setPolicy("automatic", "automatic")
 ##
 window <- gtkWindow()
 window['border-width'] <- 15
 window$add(scrolled_window)
\end{Sinput}
\end{Schunk}
%
To set all the text in the buffer requires accessing the underlying
buffer:
\begin{Schunk}
\begin{Sinput}
 buffer <- view$getBuffer()
 buffer$setText("Lorem ipsum dolor sit amet ...")
\end{Sinput}
\end{Schunk}

Manipulating the text requires an understanding of how positions are
referred to within the buffer (iterators or marks). As an indicator,
to get the contents of the buffer may be done as follows:
\begin{Schunk}
\begin{Sinput}
 start <- buffer$getStartIter()$iter    
 end <- buffer$getEndIter()$iter
 buffer$getText(start, end)
\end{Sinput}
\begin{Soutput}
[1] "Lorem ipsum dolor sit amet ..."
\end{Soutput}
\end{Schunk}

\end{example}

%% simple use -- replace, Append, insert at cursor
\paragraph{Adding text}
Text may be added programmatically through various methods of the text
buffer. The most basic \method{setText}{GtkTextBuffer}, which simply
replaces the current text, is shown in the example above. The method
\method{insertAtCursor}{GtkTextBuffer} will add the text to the buffer
at the current position of the cursor.  Other means are described in
the following sections.

\paragraph{Properties}
By default, the text in a view is editable. This can be disabled
through the \property{editable}{GtkTextView} property. Typically, one
then sets the \property{cursor-visible}{GtkTextView} property to
\qcode{FALSE} so that the cursor is hidden:
\begin{Schunk}
\begin{Sinput}
 view['editable'] <- FALSE
 view['cursor-visible'] <- FALSE
\end{Sinput}
\end{Schunk}

%% properties: editable, ...
\paragraph{Formatting}
The text view supports several general formatting options. Automatic
line wrapping is enabled through \method{setWrapMode}{GtkTextView},
which takes values from \code{GtkWrapMode}: \qcode{none},
\qcode{char}, \qcode{word}, or \qcode{word\_char}. The justification
for the entire buffer is controlled by the \code{justification}
property which takes values of \qcode{left}, \qcode{right},
\qcode{center}, or \qcode{fill} from \code{GtkJustification}.  The
global value may be overridden for parts of the text buffer through
the use of text tags, see Section~\ref{sec:gtk-mvc-text-tags}. The
left and right margins are adjusted through the \code{left-margin} and
\code{right-margin} properties.

%% buffer - wide font
\paragraph{Fonts}
%% ML: do we need a general overview of Pango fonts?
The size and font can be globally set for a text view using the
\method{modifyFont}{GtkWidget} method. To set the font for specific
regions, use text tags (see Section~\ref{sec:gtk-mvc-text-tags}). The
font is specified as a Pango font description, which may be generated
from a string through \code{pangoFontDescriptionFromString}. These
strings may contain up to 3 parts: the first is a comma-separated list
of font families, the second a white-space separated list of style
options, and the third a size in points or pixels if the units ``px''
are included. A typical value might look like \code{"serif, monospace
  bold italic condensed 16"}. The various style options are enumerated
in \code{PangoStyle}, \code{PangoVariant}, \code{PangoWeight},
\code{PangoStretch}, and \code{PangoGravity}. The help page for
\code{PangoFontDescription} contains more information.

%% ML: stuff that could be described: automatic scrolling, and mapping
%% locations to text iterators. Already mentioned in the example though.

\section{Text buffers}
\label{sec:RGtk2:text-buffers}

Text buffer properties include \code{text} for the stored text and
\code{has-selection} to indicate if text is currently selected in a
view. The buffer also tracks if it has been modified. This information
is available through the buffer \method{getModified}{GtkTextBuffer}
method, which returns \code{TRUE} if the buffer has changed. To clear
this state, such as when a buffer has been saved to disk, one can pass
\code{FALSE} to \method{setModified}{GtkTextBuffer}.

In order to do more with a text buffer, such as retrieve a selection,
or modify text attributes, one needs to become familiar with the two
mechanism for referencing text in a buffer: iterators and marks.  A
text iterator is an opaque, transient pointer to a region of text,
whereas a text mark specifies a location that remains valid across
buffer modifications.

\subsection{Iterators}

%% text iters. GetStartIterm GetEndIter, GetSelectionBounds
%% transient

%% An iterator
In \GTK{} a \dfn{text iterator} is the primary means of specifying a
position in a buffer.  As mentioned in
Section~\ref{sec:RGtk2:mvc:iterators}, iterators are typically
transient, in the sense that they are invalidated or updated by
reference when their source is modified.

%% methods to return an iterator
Several methods of the text buffer return iterators marking positions
in the buffer.  Iterators are returned as lists with two components:
\code{iter}, which represents the actual C iterator object, and
\code{retval}, a logical value indicating whether the iterator is
valid.  The beginning and end of the buffer are returned by the
methods \method{getStartIter}{GtkTextBuffer} and
\method{getEndIter}{GtkTextBuffer}. Both of these iterators are
returned together in a list by the method
\method{getBounds}{GtkTextBuffer}.  For example:
\begin{Schunk}
\begin{Sinput}
 bounds <- buffer$getBounds()
 bounds
\end{Sinput}
\begin{Soutput}
$retval
NULL

$start
<pointer: 0x124023d90>
attr(,"interfaces")
character(0)
attr(,"class")
[1] "GtkTextIter" "GBoxed"      "RGtkObject" 

$end
<pointer: 0x124023ca0>
attr(,"interfaces")
character(0)
attr(,"class")
[1] "GtkTextIter" "GBoxed"      "RGtkObject" 
\end{Soutput}
\end{Schunk}
%
%% JV in the following I had to change bounds$start$iter to just
%% bounds$start. Not sure if this has changed in the newer RGtk2 -- I
%% had trouble installing the svn version due to a missing cairo
%% function. I'm stuck for now with the 2.18 from att.research.com package
The current selection is returned by the method
\method{getSelectionBounds}{GtkTextBuffer}, as a list of the same
structure. If there is no selection, then the component \code{retval}
will be \code{FALSE}, otherwise it is \code{TRUE}.

One can also obtain an iterator for a specific position in a
document. The method \method{getIterAtLine}{GtkTextBuffer} will return an
iterator pointing to the start of the line, which is specified by
$0$-based line number. The method
\method{getIterAtLineOffset}{GtkTextBuffer} has an additional argument
to specify the offset for a given line. An offset counts the number of
individual characters and keeps track of the fact that the text
encoding, UTF-8, may use more than one byte per character. For
example, we might request the seventh character of the first line:
\begin{Schunk}
\begin{Sinput}
 iter <- buffer$getIterAtLineOffset(0, 6)
 iter$iter$getChar()                     # unicode, not text
\end{Sinput}
\begin{Soutput}
[1] 105
\end{Soutput}
\end{Schunk}
%
In addition to the text buffer, a text view also has the method
\method{getIterAtLocation}{GtkTreeView} to return the iterator
indicating the between-word space in the buffer closest to the point
specified in $x$-$y$ coordinates.

Once we obtain an iterator, we typically enter a loop which performs
some operation on the text at the iterator position and updates the
iterator with each iteration. This requires retrieving the text to
which an iterator refers. The character at the iterator position is
returned by \method{getChar}{GtkTextIter}. We obtain the first
character in the buffer:
\begin{Schunk}
\begin{Sinput}
 bounds$start$getChar()                  # unicode
\end{Sinput}
\begin{Soutput}
[1] 76
\end{Soutput}
\end{Schunk}
%
To obtain the text between two text
iterators, call the \method{getText}{GtkTextIter} method on the left
iterator, passing the right iterator as an argument:
\begin{Schunk}
\begin{Sinput}
 bounds$start$getText(bounds$end)
\end{Sinput}
\begin{Soutput}
[1] "Lorem ipsum dolor sit amet ..."
\end{Soutput}
\end{Schunk}
%
The \method{insert}{GtkTextBuffer} method will insert
text at a specified iterator:
\begin{Schunk}
\begin{Sinput}
 buffer$insert(bounds$start, "prefix")
\end{Sinput}
\end{Schunk}
%
The \method{delete}{GtkTextBuffer} method will delete the text between
two iterators.  An important observation is that we always pass the
actual iterator, i.e., the \code{iter} component of the list, to the
above methods. Passing the original list would not work.

%% iter methods
Next, we introduce the methods for updating an iterator. One can move
an iterator forward or backward, stopping at a certain type of
landmark. Supported landmarks include characters
(\method{forwardChar}{GtkTextIter},
\method{forwardChars}{GtkTextIter},
\method{backwardChar}{GtkTextIter}, and
\method{backwordChars}{GtkTextIter}), words
(\method{forwardWordEnd}{GtkTextIter},
\method{backwardWordStart}{GtkTextIter}), and sentences
(\method{backwardSentenceStart}{GtkTextIter} and
\method{forwardSentenceEnd}{GtkTextIter}).  There are also various
methods, such as \method{insideWord}{GtkTextIter}, for determining the
textual context of the iterator. Example~\ref{eg:RGtk2-find-word}
shows how some of the above are used, in particular how these methods
update the iterator rather than return a new one.

\begin{example}{Finding the word that is clicked by the user}{eg:RGtk2-find-word}
%%

This example shows how one can find the iterator corresponding to a
mouse click. In the callback we obtain the $X$ and $Y$ coordinates of
the mouse button press event, find the corresponding iterator, and
retrieve the surrounding word:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(view, "button-press-event", 
        f=function(view, event, ...) {
          start <- view$getIterAtLocation(event$getX(), 
                                          event$getY())$iter
          end <- start$copy()
          start$backwardWordStart()
          end$forwardWordEnd()
          val <- start$getText(end)
          print(val)
          return(FALSE) # call next handler
        })
\end{Sinput}
\end{Schunk}
\end{example}

\subsection{Marks}

A text mark tracks a position in the document that is relative to
other text and is preserved across buffer modifications. One can think
of a mark as an invisible object stuck between two characters. An
example is the text cursor, the position of which is represented by a
mark.

Marks are identified by name. We retrieve the mark for the
cursor, which is called \qcode{insert}:
\begin{Schunk}
\begin{Sinput}
 insert <- buffer$getMark("insert")
\end{Sinput}
\end{Schunk}

To access the text at a mark, we need to find the corresponding iterator:
\begin{Schunk}
\begin{Sinput}
 insert_iter <- buffer$getIterAtMark(insert)$iter
 bounds$start$getText(insert_iter)
\end{Sinput}
\begin{Soutput}
[1] "Lorem ipsum dolor sit amet ..."
\end{Soutput}
\end{Schunk}

Marks have a gravity of \qcode{left} or \qcode{right}, with
\qcode{right} being the default. If text is inserted at a mark with
right gravity, then the mark is moved to the end of the insertion. A
mark with left gravity would not be moved. This is intuitive if one
relates it to the behavior of the text cursor, which has right
gravity. For obvious reasons, the cursor always advances as the user
inserts text by typing. We demonstrate this programmatically:
\begin{Schunk}
\begin{Sinput}
 insert_iter$getOffset()
\end{Sinput}
\begin{Soutput}
[1] 36
\end{Soutput}
\begin{Sinput}
 buffer$insert(insert_iter, "at insertion point")
 buffer$getIterAtMark(insert)$iter$getOffset()
\end{Sinput}
\begin{Soutput}
[1] 54
\end{Soutput}
\end{Schunk}

A custom mark is created with its name, gravity and position. We
create one for the start of the document:
\begin{Schunk}
\begin{Sinput}
 mark <- buffer$createMark(mark.name = "start", 
                           where = buffer$getStartIter()$iter, 
                           left.gravity = TRUE)
\end{Sinput}
\end{Schunk}
%
By setting \argument{left.gravity}{gtkTextBufferCreateMark} to \qcode{TRUE}, the
iterator will not move when text is inserted.

%% tag Table
\subsection{Tags}
\label{sec:gtk-mvc-text-tags}

Tags are annotations placed on specific regions of a text buffer. To
create a tag, we call the \method{createTag}{GtkTextBuffer} method,
which takes an argument for each attribute to apply to the text. Here,
we create three tags: one for bold text, one for italicized text and
one for large text:
\begin{Schunk}
\begin{Sinput}
 tag_bold <- buffer$createTag(tag.name="bold", 
                              weight=PangoWeight["bold"])
 tag_emph <- buffer$createTag(tag.name="emph", 
                              style=PangoStyle["italic"])
 tag_large <- buffer$createTag(tag.name="large", 
                               font="Serif normal 18")
\end{Sinput}
\end{Schunk}
%
Next, we associate the tags with one or more regions of text:
\begin{Schunk}
\begin{Sinput}
 iter <- buffer$getBounds()
 buffer$applyTag(tag_bold, iter$start, iter$end) # iters update
 buffer$applyTagByName("emph", iter$start, iter$end)
\end{Sinput}
\end{Schunk}

\iprogram{clipboard}
\subsection{Selection and the clipboard}

The selection is defined by the text buffer as the region between the
\qcode{insert} and \qcode{selection\_bound} marks. While we could
directly move the marks around, calling
\method{selectRange}{GtkTextBuffer} is more efficient and
convenient. Here, we select the first word:
\begin{Schunk}
\begin{Sinput}
 start_iter <- buffer$getStartIter()$iter
 end_iter <- start_iter$copy(); end_iter$forwardWordEnd()
 buffer$selectRange(start_iter, end_iter)
\end{Sinput}
\end{Schunk}

\class{GtkTextBuffer} provides some convenience methods for
interaction with the clipboard: \method{copyCliboard}{GtkTextBuffer},
\method{cutClipboard}{GtkTextBuffer} and
\method{pasteClipboard}{GtkTextBuffer}. To use these, we first need a
clipboard object:
\begin{Schunk}
\begin{Sinput}
 clipboard <- gtkClipboardGet()
\end{Sinput}
\end{Schunk}
%
We can then, for example, copy the selected text (the first word) and
paste it at the end:
\begin{Schunk}
\begin{Sinput}
 buffer$copyClipboard(clipboard)
 buffer$pasteClipboard(clipboard, 
             override.location = buffer$getEndIter()$iter, 
             default.editable = TRUE)
\end{Sinput}
\end{Schunk}
%
The \argument{default.editable}{pasteClipboard} indicates that the
pasted text should be editable. If we had passed \qcode{NULL}, to the
\argument{override.location}{pasteClipboard} argument, the insertion
would have occurred at the cursor.

% \begin{example}{Adding parentheses highlighting}{eg:RGtk2:paren-highlight}
%   \SweaveInput{ex-RGtk2-match-parentheses}
% \end{example}

%% insert images or widgets
\subsection{Inserting non-text items}

If desired, one can insert images and/or widgets into a text
buffer. The method \method{insertPixbuf}{GtkTextBuffer} will insert a
\class{GdkPixbuf} object. The buffer will count the image as a
character, although \method{getText}{GtkTextBuffer} will obviously not
return the image.

Arbitrary child widgets, like a button, can also be inserted. First,
one must create an anchor in the text buffer with
\method{createChildAnchor}{GtkTextBuffer}:
\begin{Schunk}
\begin{Sinput}
 anchor <- buffer$createChildAnchor(buffer$getEndIter()$iter)
\end{Sinput}
\end{Schunk}
%
To add the widget, we call the text view method
\method{addChildAtAnchor}{GtkTextView}:
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton("click me")
 view$addChildAtAnchor(button, anchor)
\end{Sinput}
\end{Schunk}

\begin{example}{A simple command line interface}{eg:RGtk2-command-line}
This example shows how to create a simple command line interface with
the text view widget (Figure~\ref{fig:RGtk2-terminal}). While few statistical applications will include
a command line widget, the example is familiar and shows several
different, but useful, aspects of the widget.

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{ex-RGtk2-terminal}
  \caption{A basic \R\/ terminal implemented using a \code{gtkTextView} widget.}
  \label{fig:RGtk2-terminal}
\end{figure}


We begin by defining our text view widget and retrieving its
buffer then we specify a fixed-width font for the buffer:
\begin{Schunk}
\begin{Sinput}
 view <- gtkTextView()
 buffer <- view$getBuffer()
 font <- pangoFontDescriptionFromString("Monospace")
 view$modifyFont(font)                     # widget wide
\end{Sinput}
\end{Schunk}

We will use a few formatting tags, defined next. We do not need the
tag objects as variables in the workspace, as we refer to them later
by name.
\begin{Schunk}
\begin{Sinput}
 buffer$createTag(tag.name = "cmdInput")
 buffer$createTag(tag.name = "cmdOutput", 
                  weight = PangoWeight["bold"])
 buffer$createTag(tag.name = "cmdError", 
        weight = PangoStyle["italic"], foreground = "red")
 buffer$createTag(tag.name = "uneditable", editable = FALSE)
\end{Sinput}
\end{Schunk}

We define a mark to indicate the beginning of a newly entered
command, and another mark tracks the end of the buffer:
\begin{Schunk}
\begin{Sinput}
 start_cmd <- buffer$createMark("start_cmd", 
                               buffer$getStartIter()$iter, 
                               left.gravity = TRUE)
 bufferEnd <- buffer$createMark("bufferEnd", 
                                buffer$getEndIter()$iter)
\end{Sinput}
\end{Schunk}


There are two types of prompts needed: one for entering a new command
and one for a continuation. This function adds either, depending on
its argument:
\begin{Schunk}
\begin{Sinput}
 add_prompt <- function(obj, prompt = c("prompt", "continue"),
                       set_mark = TRUE) 
 {
   prompt <- match.arg(prompt)
   prompt <- getOption(prompt)
   
   end_iter <- obj$getEndIter()
   obj$insert(end_iter$iter, prompt)
   if(set_mark)
     obj$moveMarkByName("start_cmd", end_iter$iter)
   obj$applyTagByName("uneditable", obj$getStartIter()$iter, 
                      end_iter$iter)
 }
 add_prompt(buffer) ## place an initial prompt
\end{Sinput}
\end{Schunk}

This helper method writes the output of a command to the text
buffer:
\begin{Schunk}
\begin{Sinput}
 add_ouput <- function(obj, output, tag_name = "cmdOutput") {
   end_iter <- obj$getEndIter()
   if(length(output) > 0)  
     sapply(output, function(i)  {
       obj$insertWithTagsByName(end_iter$iter, i, tag_name)
       obj$insert(end_iter$iter, "\n", len=-1)
     })
 }
\end{Sinput}
\end{Schunk}
%
We did not arrange to truncate large outputs, but that would be a nice
addition. By passing in the tag name, we can specify whether this is
normal output or an error message.

This next function uses the \code{start\_cmd} mark and the end of the buffer
to extract the current command. The \qcode{regex} is used to parse multi-line commands.
\begin{Schunk}
\begin{Sinput}
 find_cmd <- function(obj) {
   end_iter <- obj$getEndIter()
   start_iter <- obj$getIterAtMark(start_cmd)
   cmd <- obj$getText(start_iter$iter, end_iter$iter, TRUE)
   regex <- paste("\n[", getOption("continue"), "] ", sep = "")
   cmd <- unlist(strsplit(cmd, regex))
   cmd
 }
\end{Sinput}
\end{Schunk}
%

The following function takes the \iprogram{evaluating strings}current command and evaluates it
using the \pkg{evaluate} package. It uses a hack (involving
\code{grepl}) to distinguish between an incomplete command and a true
syntax error.

\begin{Schunk}
\begin{Sinput}
 require(evaluate)
 eval_cmd <- function(view, cmd) {
   buffer <- view$getBuffer()
   out <- try(evaluate:::evaluate(cmd, .GlobalEnv), 
              silent = TRUE)
 
   if(inherits(out, "try-error")) {
     ## parse error
     add_ouput(buffer, out, "cmdError")
   } else if(inherits(out[[2]], "error")) {
     if(grepl("end", out[[2]])) {        # a hack here
       add_prompt(buffer, "continue", set_mark = FALSE)
       return()
     } else {
       add_ouput(buffer, out[[2]]$message, "cmdError")
     }
   } else {
     add_ouput(buffer, out[[2]], "cmdOutput")
   }
   add_prompt(buffer, "prompt", set_mark = TRUE)
 }
\end{Sinput}
\end{Schunk}

We arrange that the \code{eval\_cmd} command is called when the
\kbd{return} key is pressed next. Other key bindings might also be of
interest, such as one for \kbd{tab} completion.
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(view, "key-release-event", 
                f=function(view, event) {
                  buffer <- view$getBuffer()
                  keyval <- event$getKeyval()
                  if(keyval == GDK_Return) {
                    cmd <- find_cmd(buffer)
                    if(length(cmd) && nchar(cmd) > 0)
                      eval_cmd(view, cmd)
                  }
                })
\end{Sinput}
\end{Schunk}

%
%% ML: what is going on here? why is the signal commented out?
%% JV: Dunno, added it back in...
Finally, we connect \function{moveViewport} to the \code{changed}
signal of the text buffer, so that the view always scrolls to the
bottom when the contents of the buffer are modified:

\begin{Schunk}
\begin{Sinput}
 scroll_viewport <- function(view, ...) {
   view$scrollToMark(bufferEnd, within.margin = 0)
   return(FALSE)
 }
 gSignalConnect(buffer, "changed", scroll_viewport, data = view, 
                after = TRUE, user.data.first = TRUE)
\end{Sinput}
\end{Schunk}




\end{example}


% \begin{example}{Simple textview usage}{eg:RGtk2:simple-textview-usage}
%   \SweaveInput{ex-RGtk2-simple-textview}
% \end{example}





\chapter{RGtk2: Application Windows}
\label{sec:RGtk2-menus}
% Menus in RGtk2


In the traditional WIMP-style GUI, the user executes commands by
selecting items from a menu. In GUI terminology, such a command is
known as an \textit{action}. A GUI may provide more than one control
for executing a particular action. Menu bars and tool bars are the two
most common widgets for organizing application-wide actions. An
application also needs to report its status in an unobtrusive
way. Thus, a typical application window contains, from top to bottom, 
a menu bar, a tool bar, a large application-specific region, and a
status bar.  In this chapter, we will introduce actions, menus,
tool bars and status bars and conclude by explaining the mechanisms in
\GTK\/ for conveniently defining and managing actions and associated
widgets in a large application.


\section{Actions}
\label{sec:RGtk2:actions}


\GTK\/ represents actions with the \class{GtkAction} class. A
\class{GtkAction} can be proxied by widgets like buttons in a
\class{GtkMenubar} or \class{GtkToolbar}.  The \constructor{gtkAction}
function is the constructor:
\begin{Schunk}
\begin{Sinput}
 action <- gtkAction(name = "ok", label = "_Ok", 
              tooltip = "An OK button", stock.id = "gtk-ok")
\end{Sinput}
\end{Schunk}
%
The constructor takes arguments \argument{name}{gtkAction} (to
programmatically refer to the action), \argument{label}{gtkAction}
(the displayed text), \argument{tooltip}{gtkAction}, and
\argument{stock.id}{gtkAction} (identifying a stock icon).  The
command associated with an action is implemented by a callback
connected to the \signal{activate} signal:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(action, "activate", 
                f = function(action, data) {
                  print(action$getName())
                })
\end{Sinput}
\end{Schunk}


\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{ex-RGtk2-action-items-infobar}
  \caption{An application window mock up showing a menubar, toolbar,
  and info bar}
  \label{fig:RGtk2-action-items-infobar}
\end{figure}

An action plays the role of a data model describing a command, while
widgets that implement the \class{GtkActivatable} interface are the
views and controllers. All buttons, menu items and tool items
implement \class{GtkActivatable} and thus may serve as action
proxies. Actions are connected to widgets through the method
\method{setRelatedAction}{GtkActivatable}:
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton()
 button$setRelatedAction(action)
\end{Sinput}
\end{Schunk}
%
Certain aspects of a proxy widget are coordinated through the
action. This includes sensitivity and visibility, corresponding to the
\code{sensitive} and \code{visible} properties. By default, aesthetic
properties like the \code{label} and \code{stock-id} are also
inherited.

Often, the commands in an application have a natural grouping. It can
be convenient to coordinate the sensitivity and visibility of entire
groups of actions. \class{GtkActionGroup} represents a group of
actions. By convention, keyboard accelerators are organized by group,
and the accelerator for an action is usually specified upon insertion:
\begin{Schunk}
\begin{Sinput}
 group <- gtkActionGroup()
 group$addActionWithAccel(action, "<control>O")
\end{Sinput}
\end{Schunk}

In addition to the properties already introduced, an action may have a
shorter label for display in a toolbar (\code{short\_label}), and
hints for when to display its label (\code{is\_important}) and image
(\code{always\_show\_image}).

There is a special type of action that has a toggled state:
\class{GtkToggleAction}. The \code{active} property represents the
toggle. A further extension is \class{GtkRadioAction}, where the
toggled state is shared across a list of radio actions, via the
\code{group} property. Proxy widgets represent toggle and radio
actions with controls resembling check boxes and radio buttons,
respectively. Here, we create a toggle action for fullscreen mode:
\begin{Schunk}
\begin{Sinput}
 full_screen_action <- 
   gtkToggleAction("fullscreen", "Full screen", 
                   "Toggle full screen",
                   stock.id = "gtk-fullscreen")
 gSignalConnect(full_screen_action, "toggled", function(action) {
   if(full_screen_action['active'])
     window$fullscreen()
   else
     window$unfullscreen()
 })
\end{Sinput}
\end{Schunk}
%
We connect to the \code{toggled} signal to respond to a change in the
action state.


\section{Menus}
\label{sec:RGtk2:menus}

A menu is a compact, hierarchically organized collection of buttons,
each of which may proxy an action. Menus listing window-level actions
are usually contained within a menubar at the top of the window or
screen. Menus with options specific to a particular GUI element may
``popup'' when the user interacts with the element, such as by
clicking the right mouse button. Menubars and popup menus may be
constructed by appending each menu item and submenu separately, as
illustrated below. For menus with more than a few items, we recommend
the strategies described in Section~\ref{sec:RGtk2:UIManager}.

\subsection{Menubars}

We will first demonstrate the menubar, leaving the popup menu for
later. Figure~\ref{fig:RGtk2-action-items-infobar} will show a
realization. The first step is to construct the menubar itself:
\begin{Schunk}
\begin{Sinput}
 menubar <- gtkMenuBar()
\end{Sinput}
\end{Schunk}


A menubar is a special type of container called a menu shell. An
instance of \class{GtkMenuShell} contains one or more menu
items. \class{GtkMenuItem} is an implementation of
\class{GtkActivatable}, so each menu item can proxy an
action. Usually, a menubar consists of multiple instances of the other
type of menu shell: the menu, \class{GtkMenu}. Here, we create a menu
object for our ``File'' menu:
\begin{Schunk}
\begin{Sinput}
 file_menu <- gtkMenu()
\end{Sinput}
\end{Schunk}
%
As a menu is not itself a menu item, we first must embed the menu
into a menu item, which is labeled with the menu title:
\begin{Schunk}
\begin{Sinput}
 file_item <- gtkMenuItemNewWithMnemonic(label = "_File")
 file_item$setSubmenu(file_menu)
\end{Sinput}
\end{Schunk}
%
The underscore in the label indicates the key associated with the
mnemonic for use when navigating the menu with a keyboard.  Finally,
we append the item containing the file menu to the menubar:
\begin{Schunk}
\begin{Sinput}
 menubar$append(file_item)
\end{Sinput}
\end{Schunk}
%
In addition to \method{append}{GtkMenuShell}, it is also possible to
\method{prepend}{GtkMenuShell} and \method{insert}{GtkMenuShell} menu
items into a menu shell. As with any container, one can
\method{remove}{GtkContainer} a child menu item, although the
convention is to desensitize an item, through the \code{sensitive}
property, when it is not currently relevant.

Next, we populate our file menu with menu items that perform some
command. For example, we may desire an open item:
\begin{Schunk}
\begin{Sinput}
 open_item <- gtkMenuItemNewWithMnemonic("_Open")
\end{Sinput}
\end{Schunk}
%
This item does not have an associated \class{GtkAction}, so we need to
implement its activate signal directly:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(open_item, "activate", function(item) {
   file.show(file.choose())
 })
\end{Sinput}
\end{Schunk}
%
The item is now ready to be added to the file menu:
\begin{Schunk}
\begin{Sinput}
 file_menu$append(open_item)
\end{Sinput}
\end{Schunk}

It is recommended, however, to create menu items that proxy an
action. This will facilitate, for example, adding an equivalent
toolbar item later. We demonstrate with a ``Save'' action:
\begin{Schunk}
\begin{Sinput}
 save_action <- 
   gtkAction("save", "Save", "Save object", "gtk-save")
\end{Sinput}
\end{Schunk}
%
Then the appropriate menu item is generated from the action and added
to the file menu:
\begin{Schunk}
\begin{Sinput}
 save_item <- save_action$createMenuItem()
 file_menu$append(save_item)
\end{Sinput}
\end{Schunk}

A simple way to organize menu items, besides grouping into menus, is
to insert separators between logical groups of items. Here, we insert
a separator item, rendered as a line, to group the open and save
commands apart from the rest of the menu:
\begin{Schunk}
\begin{Sinput}
 file_menu$append(gtkSeparatorMenuItem())
\end{Sinput}
\end{Schunk}

Toggle menu items, i.e., a label next to a check box, are also
supported. A toggle action will create one implicitly:
\begin{Schunk}
\begin{Sinput}
 auto_save_action <- gtkToggleAction("autosave", "Autosave", 
                                     "Enable autosave")
 auto_save_item <- auto_save_action$createMenuItem()
 file_menu$append(auto_save_item)
\end{Sinput}
\end{Schunk}

Finally, we add our menubar to the top of a window:
\begin{Schunk}
\begin{Sinput}
 main_mindow <- gtkWindow()
 vbox <- gtkVBox()
 main_mindow$add(vbox)
 vbox$packStart(menubar, FALSE, FALSE)
\end{Sinput}
\end{Schunk}

\subsection{Popup menus}

\begin{example}{Popup menus}{ex:RGtk2-popup-menus}
To illustrate popup menus, we construct one and display it in response
to a mouse click. We start with a \code{gtkMenu} instance, to which we
add some items:
\begin{Schunk}
\begin{Sinput}
 popup <- gtkMenu()                       # top level
 popup$append(gtkMenuItem("cut"))
 popup$append(gtkMenuItem("copy"))
 popup$append(gtkSeparatorMenuItem())
 popup$append(gtkMenuItem("paste"))
\end{Sinput}
\end{Schunk}

Let us assume that we have a button that will popup a menu when
clicked with the third (right) mouse button:
\begin{Schunk}
\begin{Sinput}
 button <- gtkButton("Click me with right mouse button")
 window <- gtkWindow(); window$setTitle("Popup menu example")
 window$add(button)
\end{Sinput}
\end{Schunk}

This menu will be shown by calling \code{gtkMenuPopup} in response to
the \code{button-press-event} signal on the button:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(button, "button-press-event",
        f = function(button, event, menu) {
          if(event$getButton() == 3 ||
             (event$getButton() == 1 && # a mac
              event$getState() == GdkModifierType['control-mask'])) 
            gtkMenuPopup(menu, 
                         button = event$getButton(),
                         activate.time = event$getTime())
          return(FALSE)
        }, data = popup)
\end{Sinput}
\end{Schunk}
%
The \function{gtkMenuPopup} function is called with the menu, some
optional arguments for placement, and some values describing the
event: the mouse button and time. The event values can be retrieved
from the second argument of the callback (a \code{GdkEvent}).

The above will popup a menu, but until we bind a callback to the
\code{activate} signal on each item, nothing will happen when a menu
item is selected. Below we supply a stub for sake of illustration:
\begin{Schunk}
\begin{Sinput}
 sapply(popup$getChildren(), function(child) {
   if(!inherits(child, "GtkSeparatorMenuItem")) # skip these
     gSignalConnect(child, "activate",
            f = function(child, data) message("replace me"))
 })
\end{Sinput}
\end{Schunk}
%
We iterate over the children, avoiding the separator.
\end{example}

\section{Toolbars}
\label{sec:RGtk2:toolbars}

Toolbars are like menubars in that they are containers for
activatable items, but toolbars are not hierarchical. Also, their
items are usually visible for the life-time of the application, not
upon user interaction. Thus, toolbars are not appropriate for storing a
large number of items, only those that are activated most often.

We begin by constructing an instance of \class{GtkToolbar}:
\begin{Schunk}
\begin{Sinput}
 toolbar <- gtkToolbar()
\end{Sinput}
\end{Schunk}

In analogous fashion to the menubar, toolbars are containers for tool
items. Technically, an instance of \class{GtkToolItem} could contain
any type of widget, yet toolbars typically represent actions
with buttons. The \class{GtkToolButton} widget implements this common
case.  Here, we create a tool button for opening a file:
\begin{Schunk}
\begin{Sinput}
 open_button <- gtkToolButton(stock.id = "gtk-open") 
\end{Sinput}
\end{Schunk}
%
Tool buttons have a number of properties, including \code{label} and
several for icons. Above, we specify a stock identifier,
for which there is a predefined translated label and theme-specific icon.
As with any other container, the button may be added to the toolbar with
the \method{add}{GtkContainer} method:
\begin{Schunk}
\begin{Sinput}
 toolbar$add(open_button)
\end{Sinput}
\end{Schunk}
%
This appends the open button to the end of the toolbar. To insert into
a specific position, we would call the \method{insert}{GtkToolbar} method.

Usually, any application with a toolbar also has a menubar, in which
case many actions are shared between the two containers. Thus, it is
often beneficial to construct a tool button directly from its
corresponding action:
\begin{Schunk}
\begin{Sinput}
 save_button <- save_action$createToolItem()
 toolbar$add(save_button)
\end{Sinput}
\end{Schunk}
%
A tool button is created for \code{saveAction}, created in the
previous section.

Like menus, related buttons may be grouped using separators:
\begin{Schunk}
\begin{Sinput}
 toolbar$add(gtkSeparatorToolItem())
\end{Sinput}
\end{Schunk}

Any toggle action will create a toggle tool button as its proxy:
\begin{Schunk}
\begin{Sinput}
 full_screen_button <- full_screen_action$createToolItem()
 toolbar$add(full_screen_button)
\end{Sinput}
\end{Schunk}
%
A \class{GtkToggleToolButton} embeds a \class{GtkToggleButton}, which
is depressed whenever its \code{active} property is \code{TRUE}.

As mentioned above, toolbars, unlike menus, are usually visible for the
duration of the application. This is desirable, as the actions in a
toolbar are among those most commonly performed. However, care must be
taken to conserve screen space. The toolbar \textit{style} controls
whether the tool items display their icons, their text, or both. The
possible settings are in the \gtkenum{GtkToolbarStyle} enumeration. The
default value is specified by the global \GTK\/ style (theme). Here,
we override the default to only display images:
\begin{Schunk}
\begin{Sinput}
 toolbar$setStyle("icon")
\end{Sinput}
\end{Schunk}
%
For canonical actions like \textit{open} and \textit{save}, icons are
usually sufficient. Some actions, however, may require textual
explanation. The \code{is-important} property on the action will
request display of the label in a particular tool item, in addition to
the icon:
\begin{Schunk}
\begin{Sinput}
 full_screen_action["is-important"] <- TRUE
\end{Sinput}
\end{Schunk}

Normally, tool items are tightly packed against the left side of the
toolbar. Sometimes, a more complex layout is desired. For example, we
may wish to place a \textit{help} item against the right side. We can
achieve this with an invisible item that expands against its siblings:
%% ML: use latest svn for this
\begin{Schunk}
\begin{Sinput}
 expander <- gtkSeparatorToolItem()
 expander["draw"] <- FALSE
 toolbar$add(expander)
 toolbar$childSet(expander, expand = TRUE)
\end{Sinput}
\end{Schunk}

% 
The dummy item is a separator with its \code{draw} property set to
\code{FALSE}, and its \code{expand} child property set to
\code{TRUE}. Now we can add the \textit{help} item:
\begin{Schunk}
\begin{Sinput}
 help_action <- gtkAction("help", "Help", "Get help", "gtk-help")
 toolbar$add(help_action$createToolItem())
\end{Sinput}
\end{Schunk}

It is now our responsibility to place the toolbar at the top of the
window, under the menu created in the previous section:
\begin{Schunk}
\begin{Sinput}
 vbox$packStart(toolbar, FALSE, FALSE)
\end{Sinput}
\end{Schunk}

\begin{example}{Color menu tool button}{ex:RGtk2-color-tool-button}
Space in a toolbar is limited, and sometimes there are several actions
that differ only by a single parameter. A good example is the color
tool button found in many word processors. Including a button for
every color in the palette would consume an excessive amount of
space. A common idiom is to embed a drop-down menu next to the button,
much like a combo box, for specifying the color, or, in general, any
discrete parameter.

We demonstrate how one might construct a color-selecting tool
button. Our menu will list the colors in the \R\/ palette. The
associated button is a \class{GtkColorButton}. When the user
clicks on the button, a more complex color selection dialog will
appear, allowing total customization.
\begin{Schunk}
\begin{Sinput}
 gdk_color <- gdkColorParse(palette()[1])$color
 color_button <- gtkColorButton(gdk_color)
\end{Sinput}
\end{Schunk}
% 
The \constructor{gtkColorButton} constructor requires the initial color
to be specified as a \class{GdkColor}, which we parse from the \R\/
color name.

The next step is to build the menu. Each menu item will display a
$20x20$ rectangle, filled with the color, next to the color name:
\begin{Schunk}
\begin{Sinput}
 colorMenuItem <- function(color) {
   drawing_area <- gtkDrawingArea()
   drawing_area$setSizeRequest(20, 20)
   drawing_area$modifyBg("normal", color)
   image_item <- gtkImageMenuItem(color)
   image_item$setImage(drawing_area)
   image_item
 }
 color_items <- sapply(palette(), colorMenuItem)
 color_menu <- gtkMenu()
 for (item in color_items)
   color_menu$append(item)
\end{Sinput}
\end{Schunk}
%
An important realization is that the image in a
\class{GtkImageMenuItem} may be any widget that presumably draws an
icon; it need not be an actual \class{GtkImage}. In this case, we use
a drawing area with its background set to the color.  When an item is
selected, its color will be set on the color button:
\begin{Schunk}
\begin{Sinput}
 colorMenuItemActivated <- function(item) {
   color <- gdkColorParse(item$getLabel())$color
   color_button$setColor(color)
 }
 sapply(color_items, gSignalConnect, "activate", 
        colorMenuItemActivated)
\end{Sinput}
\end{Schunk}


Finally, we place the color button and menu together in the menu tool
button:
\begin{Schunk}
\begin{Sinput}
 menu_button <- gtkMenuToolButton(color_button, "Color")
 menu_button$setMenu(color_menu)
 toolbar$add(menu_button)
\end{Sinput}
\end{Schunk}
\end{example}
  
%% GtkToolPalette as a compromise between menus and toolbars

Some applications may offer a large number of actions, where there is
no clear subset of actions that are more commonly performed than the
rest. It would be impractical to place a tool item for each action in
a static toolbar. \GTK\/ provides a \textit{tool palette} widget as
one solution, which leaves the configuration of a multi-row toolbar to
the user. The tool items are organized into collapsible groups, and
the grouping is customizable through drag and drop.

\class{GtkToolPalette} is a container of \class{GtkToolItemGroup}
widgets, each of which is a container of tool items and implements
\class{GtkToolShell}, like \class{GtkToolbar}. We begin our brief
example by creating a two groups of tool items:
%% JV: commented out next 3 for eval as my GTK is a bit to old to run. --Need
%% to update
%% ML: went ahead and uncommented them, assuming you've updated
%% JV: SOrry, stuck with 2.18 for now.
\begin{Schunk}
\begin{Sinput}
 file_group <- gtkToolItemGroup("File")
 file_group$add(gtkToolButton(stock.id = "gtk-open"))
 file_group$add(save_action$createToolItem())
 help_group <- gtkToolItemGroup("Help")
 help_group$add(help_action$createToolItem())
\end{Sinput}
\end{Schunk}
%

The groups are then added to an instance of \class{GtkToolPalette}:
\begin{Schunk}
\begin{Sinput}
 palette <- gtkToolPalette()
 palette$add(file_group)
 palette$add(help_group)
\end{Sinput}
\end{Schunk}
%
Finally, we can programmatically collapse a group:
\begin{Schunk}
\begin{Sinput}
 help_group$setCollapsed(TRUE)
\end{Sinput}
\end{Schunk}

\section{Status reporting}
\label{sec:RGtk2:statusbars}

\subsection{Statusbars}

In \GTK, a status bar is constructed through the
\constructor{gtkStatusbar} function. Statusbars must be placed at the
bottom of a top-level window. A status bar keeps various stacks of
messages for display. Stacks and messages are associated with a
context ID, which represents a message source. It is required to
register each context ID against a string description. The visibility
depends on the ordering of the global stack, while the context ID
allows the status bar to maintain a separate message stack for each
part of an application, without worry of interference between
components.

To display a message, one pushes it onto the top of the global stack,
as well as a context stack, through the \method{push}{GtkStatusbar}
method, which expects an integer value for \code{context.id} and a
message.  To pop a message from a context stack, pass the context ID to
the \method{pop}{GtkStatusbar} method. If the message was on top of
the global stack, the next message down becomes visible.

Below, we create a status bar, register a context for I/O-related
messages, display the message and then pop it to restore the original
state:
\begin{Schunk}
\begin{Sinput}
 statusbar <- gtkStatusbar()
 io_id <- statusbar$getContextId("I/O")
 statusbar$push(io_id, "Incomplete final line")
 ## ...
 statusbar$pop(io_id)
\end{Sinput}
\end{Schunk}

\subsection{Information bars}
\label{sec:gtkInfoBar}

An information bar is similar in purpose to a message dialog, only it
is intended to be less obtrusive. Typically, an information bar raises
from the bottom of the window, displaying a message, possibly with
response buttons. It then fades away after a number of seconds. The
focus is not affected, nor is the user interrupted. \GTK\/ provides
the \class{GtkInfoBar} class for this purpose. The use is similar to a
dialog: one places widgets into a content area, and listens to the
\signal{response} signal.

We create our info bar:
\begin{Schunk}
\begin{Sinput}
 info_bar <- gtkInfoBar(show=FALSE)
 info_bar$setNoShowAll(TRUE)
\end{Sinput}
\end{Schunk}
We call \method{setNoShowAll}{GtkWidget} to prevent the widget from being shown
when \method{showAll}{GtkWidget} is called on the parent. Normally, an
information bar is not shown until it has a message. 

We will emit a warning message by adding a simple label with the text
and specifying the message type as \code{warning}, from
\code{GtkMessageType}:
\begin{Schunk}
\begin{Sinput}
 label <- gtkLabel("Warning, Warning ....")
 info_bar$setMessageType("warning")            
 info_bar$getContentArea()$add(label)
\end{Sinput}
\end{Schunk}

A button to allow the user to hide the bar can be added as follows:
\begin{Schunk}
\begin{Sinput}
 info_bar$addButton(button.text = "gtk-ok",
                    response.id = GtkResponseType['ok'])
\end{Sinput}
\end{Schunk}
%
This is similar to the dialog API: the appearance of the ``Ok'' button is
defined by the stock ID \code{gtk-ok}, and the response ID will be
passed to the \signal{response} signal when the button is clicked. Our
handle simply closes the bar:
\begin{Schunk}
\begin{Sinput}
 gSignalConnect(info_bar, "response", 
                function(info_bar, resp.id) info_bar$hide())
\end{Sinput}
\end{Schunk}

Finally, we add the info bar to our main window and show it:
\begin{Schunk}
\begin{Sinput}
 vbox$packStart(info_bar, expand = FALSE)
 info_bar$show()
\end{Sinput}
\end{Schunk}

\section{Managing a complex user interface}
\label{sec:RGtk2:UIManager}

Complex applications implement a large number of actions and operate
in a number of different modes. Within a given mode, only a subset of
actions are applicable. For example, a word processor may have an
editing mode and a print preview mode. \GTK\/ provides a \dfn{user
  interface manager}, \class{GtkUIManager}, to manage the layout of
the toolbars and menubars across multiple user interface modes. We
illustrate through an example.

The steps required to use \GTK's UI manager are:
\begin{enumerate}
\item construct the UI manager,
\item specify in XML the layout of the menubars and toolbars,
\item define the actions in groups,
\item connect the action group to the UI manager, 
\item set up an accelerator group for keyboard shortcuts, 
and finally
\item display the widgets.
\end{enumerate}

\begin{example}{UI manager example}{ex:RGtk2:UImanager}
In this example, we show how to use a UI manager to create the menu
and toolbars for a data frame editor, similar to, but with enhanced
functionality, the one produced on some platforms by the
\function{data.entry} function. 


\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{fig-RGtk2-editable-dataframe}
  \caption{An instance of an editable data frame with menu and tool
    bars specified using an instance of \class{GtkUIManager}. This
    example, implements the command pattern to provide simple undo and
    redo functionality.}
  \label{fig:RGtk2-editable-dataframe}
\end{figure}





Our menubar and toolbar layout is expressed in XML according to a
schema specified by the UI manager framework. The XML can be stored in
a file or an \R\/ character vector.  The structure of the file can be
grasped quickly from this example:
\begin{Schunk}
\begin{Sinput}
 ui.xml <- readLines(out <- textConnection('
 <ui>
   <menubar name="menubar">
     <menu name="FileMenu" action="File">
       <menuitem action="Save"/>
       <menuitem action="SaveAs" />
       <menu name="Export" action="Export">
         <menuitem action="ExportToCSV" />
         <menuitem action="ExportToSaveFile" />
       </menu>
       <separator />
       <menuitem name="FileQuit" action="CloseWindow" />
     </menu>
     <menu action="Edit">
       <menuitem name="EditUndo" action="Undo" />
       <menuitem name="EditRedo" action="Redo" />
       <menuitem action="ChangeColumnName" />
     </menu>
     <menu action="Tools">
       <menuitem action="Filter" />
       <menuitem action="Sort" />
     </menu>
   </menubar>
   <toolbar name="toolbar">
     <toolitem action="Save"/>
     <toolitem action="SaveAs"/>
     <separator />
     <toolitem action="CloseWindow"/>
   </toolbar>
 </ui>'), warn=FALSE)
 close(out)
\end{Sinput}
\end{Schunk}
%

We used indenting to show the nesting of the menus. For menus we see
the use of menubars, menus and menu items. The menu and menu items have a
corresponding action associated with them, which can provide a callback.

If \code{uimanager} is our \class{GtkUIManager} instance, then we can
add this through the command:
\begin{Schunk}
\begin{Sinput}
 id <- uimanager$addUiFromString(ui.xml)
\end{Sinput}
\end{Schunk}
Alternately, we could load the code from a file. The return value is
an id that can be used to unmerge this part of the UI. The ability to
merge and unmerge parts of the UI is one main attraction for using
this framework, although we do not illustrate that here. 

To define the actions, we can use lists. This list defines
the file menu:
\begin{Schunk}
\begin{Sinput}
 file_list <- 
   list(## name, ID, label, accelerator, tooltip, callback
        list("File",NULL,"_File",NULL,NULL,NULL),
        list("Save", "gtk-save", "Save", "<ctrl>S", 
             "Save data to variable", fun),
        list("SaveAs", "gtk-save", "Save as...", NULL, 
             "Save data to variable", fun),
        list("Export", NULL, "Export", NULL, NULL, NULL),
        list("ExportToCSV", "gtk-export", "Export to CSV", 
             NULL, "Save data to CSV file", fun),
        list("ExportToSaveFile", "gtk-export", 
             "Export to save file", NULL, 
             "Save data to save() file", fun),
        list("CloseWindow", "gtk-close", "Close window", 
             "<ctrl>W", "Close current window", fun)
        )
\end{Sinput}
\end{Schunk}
% 
Each item contains $6$ pieces of information: a name (which we use in
\code{fun} to call the appropriate method), a stock-id, a label, a
keyboard accelerator a tooltip, and finally a callback for when the
action is invoked.

We can add these items to an action group, along the lines of
\begin{Schunk}
\begin{Sinput}
 action_group <- gtkActionGroup("FileGroup")
 action_group$addActions(file_list)
\end{Sinput}
\end{Schunk}

We can then insert the action group into the UI manager:
\begin{Schunk}
\begin{Sinput}
 uimanager$insertActionGroup(action_group, 0)
\end{Sinput}
\end{Schunk}
%
The position (\code{0}) is used to determine which action will be
called, when there is more than one with the same name.


%% insert into GUI
We now place the UI manager into the GUI. The UI manager specification
create widgets which we can retrieve through its
\method{getWidget}{GtkUIManager} method. The following code sketches
the layout of the GUI:
\begin{Schunk}
\begin{Sinput}
 window <- gtkWindow(show = FALSE)
 ##
 vbox <- gtkVBox()
 window$add(vbox)
 ##
 menubar <- uimanager$getWidget("/menubar")
 vbox$packStart(menubar, FALSE)
 toolbar <- uimanager$getWidget("/toolbar")
 vbox$packStart(toolbar, FALSE)
 ## ...
\end{Sinput}
\end{Schunk}
%
The \code{menubar} and  \code{toolbar} widgets are referred to by
their path which come from the names specified in the XML description
separated by "/". So, in the definition. the line
\begin{verbatim}
<ui>
  <menubar name="menubar">
...
\end{verbatim}
define the path \qcode{/menubar}, where \code{<ui>} is always
the root element, and may be omitted from the path.


Finally, to connect the UI manager to the window, we add the keyboard
accelerator group:
\begin{Schunk}
\begin{Sinput}
 window$addAccelGroup(uimanager$getAccelGroup())
\end{Sinput}
\end{Schunk}

Figure~\ref{fig:RGtk2-editable-dataframe} shows an illustration of the
finished application. The full details are found in the code in our accompanying
package \pkg{ProgGUIinR}. 

\paragraph{Command pattern}
Now we discuss how the \iprogram{command pattern}\Dfn{command pattern}
was implemented to provide a simple undo and redo feature to our
editing.  According to \footcite{head-first-design-patterns}, the
command pattern is used to \iprogram{encapsulation}encapsulate a
request (method call) as an object. A basic command object has just
one method, \meth{execute}. Any needed parameters are stored in the
object as properties. The command pattern has GUI-related applications
beyond the undo/redo stack, including the action objects (i.e.,
instances of \class{GtkAction}) that are managed by
\class{GtkUIManager}.

For our implementation of the undo/redo stack, we use a reference
class with fields:
\begin{Schunk}
\begin{Sinput}
 Command <- setRefClass("Command",
                        fields = list(
                          receiver="ANY",
                          meth="character",
                          params="list",
                          old_params="list"
                          ))
\end{Sinput}
\end{Schunk}
%
The receiver is the object that receives the method call. For a simple
function call, this could be the environment enclosing the
function. The \code{meth} property is the name of the method, and
\code{params} is a list of parameters. With these we define the main
methods:
\begin{Schunk}
\begin{Sinput}
 Command$methods(
         initialize = function(receiver, meth, ...) {
           .params <- list(...)
           initFields(receiver = receiver, meth = meth, 
                      params = .params, old_params = .params)
           callSuper()
         },
         execute = function(params) {
           do.call(call_meth(meth, receiver), params)
         })
\end{Sinput}
\end{Schunk}
%

Notice we pass in the arguments to our \meth{execute} method, rather
than use those in the property \code{params}. This allows us to implement the
\meth{do} and \meth{undo} methods in a similar manner:
\begin{Schunk}
\begin{Sinput}
 Command$methods(
                 do = function() {
                   out <- execute(params)
                   old_params$value <<- out
                 },
                 undo = function() execute(old_params)
                 )
 
\end{Sinput}
\end{Schunk}
%
This assumes the method executed can return a value which can be used
to reverse the call. If a method call is not so straightforward to
reverse, one needs only subclass the \class{Command} call and provide
a new \code{undo} method.

A simple illustration might be:
\begin{Schunk}
\begin{Sinput}
 x <- 1
 set_x <- function(value) {
   old <- x
   x <<- value
   old
 }
 cmd <- Command$new(.GlobalEnv, "set_x", value = 2)
 cmd$do(); x
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
 cmd$undo();
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
 x
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\end{Schunk}

In our example, we create a stack of commands to keep track of what
was done. This stack has methods \code{add}, \code{undo} and
\code{redo}, each calling the \code{do} or \code{undo} method of the
appropriate command in the stack.

The first command we add to the stack is the setting of a column name
on a data frame:
\begin{Schunk}
\begin{Sinput}
 cmd <- Command$new(df_model, "set_col_name", j = j, value = value)
 command_stack$add(cmd)
\end{Sinput}
\end{Schunk}
%
To explain, \code{df\_model} is an instance of a yet-to-be-defined
reference class defining a data model for the data frame being edited,
and \code{j} and \code{value} are determined by a dialog called before
the command is created. The point is, the method call for the
\code{df\_model} object is encapsulated along with the needed
parameters (a column number and new name) and then added to the
command stack. The \meth{add} method calls the \code{do} method of the
command to invoke the changing of the name.

The data frame model (defined in our reference class \class{DfModel}) is a wrapper around an
\class{RGtkDataFrame} object that holds the data. The method call
above is implemented by:
\begin{Schunk}
\begin{Sinput}
 DfModel$methods(
                 get_col_name = function(j) varnames[j,1],
                 get_col_names = function() varnames[ ,1],
                 set_col_name = function(j, value) {
                   "Set name, return old"
                   old_col_name <- get_col_name(j)
                   varnames[j,1] <<- value
                   old_col_name
                 })
\end{Sinput}
\end{Schunk}
%%
We return the old value, as that is required by the implementation of
the \meth{do} method for the commands. An instance of
\class{RGtkDataFrame} stores the variable (column) names, hence the
double index. This allows us to listen for changes through the
\signal{row-changed} signal on the model. The details, and more, are
in the accompanying package.









\end{example}

%% TODO: this needs to go somewhere.. appendix?
%% JV, I guess here

\chapter{Extending GObject Classes}
\label{chapter:extending-GTK}
%\section{Extending GObject classes from R}
\label{sec:gtk:extending-classes}
\iprogram{subclass}

\GTK, as well as several of its dependencies, with the notable
exception of \pkg{Cairo}, is based on the \pkg{GObject}
library for object-oriented programming in C. \pkg{GObject} forms the
basis of many other open-source projects, including the \pkg{GNOME}
and \pkg{XFCE} desktops and the \pkg{GStreamer} multimedia framework.

Given the broad use of signals in the \GTK\/ API, it is very rarely
necessary to extend a widget class when developing a typical
GUI. However, it is generally good practice to encapsulate the
behavior of a widget in a formal class. Although there are several
such formalisms in R, \pkg{RGtk2} provides one that is congruent with
the rest of \GTK. It interfaces with parts of \pkg{GObject} and
permits the R programmer to create new \pkg{GObject} classes in R. A
subclass can override certain methods inherited from its parent and
define new methods, properties and signals. If a method is declared by
a C class, it can only be overridden if it is a so-called
\textit{virtual} method, and there is no documentation as to which
methods are virtual. There is a loose convention that every signal has
a corresponding virtual method. The ultimate resource is the C header
files. A bug in a method override could very easily crash R, so use of
this feature takes some commitment from the programmer. Any method
declared by an R class may be overridden by an R subclass.

Our example will be a GUI that displays a scatterplot along with a
slider for adjusting the alpha level of the points (Figure~\ref{fig:RGtk2-extend-gobject-slider}). Usually, a slider
operates in linear fashion. When there are a large number of points,
on the order of tens of thousands or more, changing the alpha level
does not have a strong visual effect until it approaches its lower
limit. We desire greater control in the lower part of the alpha scale,
without limiting the range of the slider. To achieve this, we need to
perform a non-linear transformation from the slider value to the alpha
of the plot and reflect that transformation in the label on the
slider. One solution is to connect to the
\signal{format-value}{GtkScale} signal to override the text in the
label. We present an alternative that involves extending
\class{GtkHScale} and overriding its \method{format\_value}{GtkScale}
virtual method.

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-RGtk2-extend-gobject} 
  \caption{An interface using a custom slider to adjust alpha levels
    in a non-linear manner}
  \label{fig:RGtk2-extend-gobject-slider}
\end{figure}

A class is defined by calling \function{gClass}, which is passed the
class name, the name of the parent class and a number of list
arguments that define the properties, signals and methods of the
class. For the sake of cleanliness, the everything is defined as part
of the \function{gClass} call:
\begin{Schunk}
\begin{Sinput}
 tform_scale_type <- 
   gClass("RTransformedHScale", "GtkHScale",
          .props = list(
            gParamSpec(type = "R", name = "expr", nick = "e", 
                       blurb = "Transformation of scale value",                 
                       default.value = expression(x))
            ),
          GtkScale = list(
            format_value = function(self, x) 
              as.character(self$transformValue(x))
            ),
          .public = list(
            getExpr = function(self) self["expr"],
            getTransformedValue = function(self) 
              self$transformValue(self$value)
            ),
          .private = list(
            transformValue = function(self, x) 
              eval(self$expr, list(x = x))
           )
          )
\end{Sinput}
\end{Schunk}

The class definition for \class{RTransformedHScale} starts with a
property for the R expression that transforms the value from the
slider to the alpha level. A property is defined by a
\class{GParamSpec} structure that specifies a name, nickname,
descriptive blurb, value type, and other options.  There are
subclasses of \class{GParamSpec} for particular types that permit
specification of further constraints. For example,
\class{GParamSpecInt} is specific to integers and can be configured to
restrict its valid range of integer values between a minimum and
maximum. Many \class{GParamSpec} subclasses also permit default
values. The \argument{type}{gParamSpec} argument may refer to any C
type by name. The names of R types, like ``integer'' and ``character''
are mapped to the corresponding scalar C type, if available. An ``R''
property, like our expression, stores any native R value. The actual R
type, as returned by \function{typeof}, may be specified as the
\argument{s.type}{gParamSpec} argument; otherwise, it is taken from
the default value.

We turn our attention to the methods in the class definition. The
class overrides the \method{format\_value} virtual from
\class{GtkScale} and defines two public methods, \code{getExpr} and
\code{getTransformedValue}, for retrieving the transformation
expression and the transformed value, respectively. There is one
private method, \code{transformValue} that is a utility for evaluating
the expression on the current value.

Methods are implemented with R functions that are grouped into lists.
The names of the list identify the methods. An override is placed into
the list corresponding to the class in which the original method is
declared.  For new methods, the division is by the access level:
public, protected or private.  Public members may be accessed by any
code, while protected members are restricted to methods belonging to
the same class or a subclass. Access to private members is the most
restricted as they are only available to methods in the same class.

A function implementing a virtual method may delegate to the method
that it overrides. This is achieved by calling the
\function{parentHandler} function and passing it the name of the method
and the arguments to forward to the method. This is similar to the
\function{super} function in \pkg{qtbase}. For example, in the
override of \signal{format\_value} in the \class{RGtkTransformedHScale}
class, we could call \code{parentHandler("format\_value", self, x)} to
delegate to the implementation of \signal{format\_value} in
\class{GtkScale}.

If a non-function, like a vector, is placed in the
\argument{.public}{gClass}, \argument{.protected}{gClass} or
\argument{.private}{gClass} list, it represents a field, which is
initialized to the given value.

Two elements of the class definition that are not in the example above
are the list of signal definitions and the initialization function.
The signal definition list is passed as a parameter named
\code{.signals} and contains a list for each signal. Each list
includes the name, return type, and parameter types of the signal. The
types may be specified in the same format as used for property
definitions. The initialization function, passed as the
\code{.initialize} parameter, is invoked whenever an instance of the
class is created, before any properties are set. It takes the newly
created instance of the class as its only parameter.

The next step in our example is to create an instance of
\code{RGtkTransformedHScale} and to register a handler on the
\code{value-changed} signal that will draw the plot using the
transformed value as the alpha setting:
\begin{Schunk}
\begin{Sinput}
 adj <- gtkAdjustment(0.5, 0.15, 1.00, 0.05, 0.5, 0)
 s <- gObject(tform_scale_type, adjustment = adj, 
              expr = expression(x^3))
 gSignalConnect(s, "value_changed", function(scale) {
   plot(ma_data, col = rgb(0, 0, 0, scale$getTransformedValue()),
        xlab = "Replicate 1", ylab = "Replicate 2", 
        main = "Expression levels of WT at time 0", pch = 19)
 })
\end{Sinput}
\end{Schunk}
%
Instances of any \pkg{GObject} class may be created using the
\code{gObject} function.  The value of the \code{expr} property is set
to the \proglang{R} expression $x^3$ when the object is created.  The
signal handler now calls the new \code{getTransformedValue} method,
instead of \code{getValue} as in the original version.  The
\code{ma\_data} object is a matrix of points that is meant to resemble
expression values from two replicates of a microarray experiment.

We complete the example by placing the slider and a graphics device in
a window:
\begin{Schunk}
\begin{Sinput}
 win <- gtkWindow(show = FALSE)
 da <- gtkDrawingArea()
 vbox <- gtkVBox()
 vbox$packStart(da)
 vbox$packStart(s, FALSE)
 win$add(vbox)
 win$setDefaultSize(400, 400)
 #
 require(cairoDevice)
 asCairoDevice(da)
 #
 win$showAll()
 par(pty = "s")
 s$setValue(0.7)
\end{Sinput}
\end{Schunk}



% \label{sec:RGtk2:dialogs}
% \SweaveInput{Pre-defined-dialogs}

% \chapter{\code{cairoDevice}}
% \label{sec:RGtk2-cairoDevice}
% \SweaveInput{cairoDevice}

% \chapter{Using \code{glade} to design GUIs}
% \label{sec:RGtk2-glade}
% \SweaveInput{Glade}

%\section{End of chapter notes}
%\label{sec:RGtk2:end-of-chapter}

% * overview in inst
% * gtk tutorial in R
% * API at http://developer.gimp.org/api/2.0/gtk/
% * ...

% * widget gallery
% https://developer-old.gnome.org/gtk2/stable/ch02.html

%  good source: http://developer-old.gnome.org/doc/GGAD/ggad.html

% * http://gtk.org/documentation.html

% * gtk API
% https://developer-old.gnome.org/gtk2/stable/

% * pango manual 
% https://developer-old.gnome.org/pango/stable

s/PangoMarkupFormat.html

% * Missing discussion on standard dialogs: message, confirmations, etc.
% filebrowser, colors selector, font selector, 

% * Mention history: GIMP; GNOME; DTL RGtk; Michael Lawrence RGtk2
% * Installation: windows; linux; mac OS X

% * Info
% php cookbook good source of info

% DTL examples from omegahat

% pygtk tutorial easier to read than C one (no types specifed)
% pygtk cookbook: http://eccentric.cx/misc/pygtk/wiki/doku.php?id=pygtk
% pygtk faq: http://faq.pygtk.org/index.py?req=index


%% Need a comparison of RGtk2 and qtbase, somewhere (appendix? qt chapter?)

%% High-level comparison of frameworks:

%% Feature     Qt            GTK+           R
%% ------------------------------------------------------------------------
%% DBus        QtDBus        GDBus (GIO)    None (RCorba is Windows Equivalent)
%% XML UI      QtUiTools     GtkBuilder     RGG (Java)  
%% GUI         QtGui         GTK+           tcltk
%% Help        QtHelp        Yelp (Gnome)   R help system (primitive)   
%% Multimedia  QtMultimedia  GStreamer      None
%% IO/Network  QtNetwork     GIO            R connections (synchronous only)
%% OpenGL      QtOpenGL      GlExt/Cairo    rgl
%% Javascript  QtScript      None           None
%% SQL         QtSql         libgda         DBI (good enough)
%% SVG         QtSvg         cairo/librsvg  cairoDevice, svgImport, etc
%% Web browser QtWebkit      GtkWebkit      None     
%% XML         QtXml         libxml         XML (binds libxml)
%% Settings    QtNetwork     GIO            Nothing really

%% Notes:
%% - DBus is likely useless, except on Linux
%% - Deepayan's qtutils package integrates R docs with QtHelp
%% - Multimedia could be useful for generating videos, etc (out of scope)
%% - R connections are very primitive (no asynchronous I/O)
%% - Qt provides 2D API for OpenGL
%% - DBI package covers database access needs
%% - SVG not designed for interactivity, <canvas> better
%% - GtkWebkit should be bound in separate package (worth it?)
%% - XML package has XML handling covered
%% - The graphics support in QtGui is a major advantage over
%%   Cairo-based GTK+. The QPainter API is better designed for stat
%%   graphics and has faster backend implementations. QGraphicsView is
%%   a mature canvas, something GTK+ lacks.

%% Summary: 
%% - Useful features in qtbase, but not RGtk2: WebKit, Multimedia
%%   - GtkWebkit, GStreamer could be bound, but not worth it, given qtbase
%%   - QtWebkit offers Javascript <-> Qt bridge via QtScript

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


